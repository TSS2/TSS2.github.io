<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://localhost:4000/"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>

  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="机器学习">










<meta name="description" content="年华似水 匆匆一瞥 多少岁月 轻描淡写">
<meta name="keywords" content="机器学习">
<meta property="og:type" content="website">
<meta property="og:title" content="童双双">
<meta property="og:url" content="#/index.html">
<meta property="og:site_name" content="童双双">
<meta property="og:description" content="年华似水 匆匆一瞥 多少岁月 轻描淡写">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="童双双">
<meta name="twitter:description" content="年华似水 匆匆一瞥 多少岁月 轻描淡写">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="#/">





  <title>童双双</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">



  <!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>




  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    
      <div class="site-meta-headline">
        <a>
          <img class="custom-logo-image" src="/uploads/cat.jpg" alt="童双双">
        </a>
      </div>
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">童双双</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">double</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2020/02/09/线性空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/09/线性空间/" itemprop="url">线性空间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-09T00:00:00+08:00">
                2020-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线性空间/" itemprop="url" rel="index">
                    <span itemprop="name">线性空间</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h1><h2 id="线性空间的定义"><a href="#线性空间的定义" class="headerlink" title="线性空间的定义"></a>线性空间的定义</h2><p>若对应法则</p>
<script type="math/tex; mode=display">f:A \longrightarrow B</script><script type="math/tex; mode=display">\quad a \longmapsto b</script><p>其中每一个$a$对应的$b$是唯一的，则称$f$是$A$到$B$的一个<font color="red">映射</font>。$b$称为$a$在$f$下的<strong>像</strong>，记作$f(a)$，$a$为$b$在$f$下的一个<strong>原像</strong>，$A$为<strong>定义域</strong>，$B$为<strong>陪域</strong>（包含了值域）。</p>
<p>$f$的值域（<font color="red">像$Imf$</font>）:$f(A):=\begin{Bmatrix}f(a)|a \in A \end{Bmatrix}$</p>
<p>若$f(A)=B$,则称$f$为一个满射；</p>
<p>若$A$中的不同元素在$f$下的像不同，则称$f$是一个单射；</p>
<p>若$f$既是一个满射又是一个单射，则称$f$是一个双射（或一一对应）。</p>
<p>$S \times M:=\begin{Bmatrix}(a,b)|a \in S,b \in M\end{Bmatrix}$称为$S$与$M$的<font color="red">笛卡儿积</font>。</p>
<p>定义：非空集合$S$上的一个<font color="red">代数运算</font>是指$S \times S$到$S$的一个映射。</p>
<p>定义：设$V$是一个非空集合，$K$是一个数域，<br>如果$V$上有一个运算，称为<strong>加法</strong>，即$V \times V \longrightarrow V:(\alpha,\beta) \longmapsto\alpha + \beta$，<br>如果$K$与$v$之间有一个运算，称为<strong>数量乘法</strong>，即$K \times V \longrightarrow V:(k,\alpha) \longmapsto k\alpha$。</p>
<p>令$V$是一个非空集合，$P$是一个数域，在集合$V$的元素之间定义了一种代数运算，叫加法；在数域$P$与集合$V$的元素之间还定义了一种运算，叫做数量乘法。如果加法与数量乘法满足下述规则，那么$V$成为数域$P$上的<font color="red">线性空间</font>。把$V$中的元素成为一个向量，线性空间也称为向量空间。如下：</p>
<p>加法满足下面四条规则：</p>
<p>$<br>1.\alpha + \beta = \beta + \alpha<br>$</p>
<p>$<br>2.(\alpha + \beta) + \gamma = \alpha + (\beta + \gamma)<br>$</p>
<p>3.在$V$中有一个元素$0$，$\forall \alpha \in V$,都有$\alpha + 0 = \alpha$ (具有这个性质的元素$0$称为$V$的零元素)</p>
<p>4.$\forall \alpha \in V,\exists \beta \in V,st \quad \alpha + \beta = 0$ ($\beta$称为$\alpha$的负元素)</p>
<p>数量乘法满足下面两条规则：</p>
<p>$<br>5.1 \alpha = \alpha<br>$</p>
<p>$<br>6.k(l \alpha) = (kl)\alpha<br>$</p>
<p>数量乘法与加法满足下面两条规则：</p>
<p>$<br>7.(k+l)\alpha = k\alpha + l\alpha<br>$</p>
<p>$<br>8.k(\alpha + \beta) = k\alpha + k\beta<br>$</p>
<p>在以上规则中，$k,l$表示数域$P$中任意数；$\alpha,\beta,\gamma$等表示集合$V$中任意元素。</p>
<p>例1：几何空间</p>
<p>{以原点O为起点的所有向量}</p>
<p>例2： $K^n:=\begin{Bmatrix}(\alpha_1,\alpha_2,…,\alpha_n)|\alpha_i \in K,i=1,2,…,n\end{Bmatrix}$是数域$K$上的一个线性空间。</p>
<p>例3：$R^X:=${非空集合$X$到$R$的映射}</p>
<p>规定：</p>
<script type="math/tex; mode=display">
(f+g)(x) := f(x) + g(x),\forall x \in X</script><script type="math/tex; mode=display">
(kf)(x) := kf(x),\forall k \in R,\forall x \in X</script><p>零函数$0(x):=0,\forall x \in X$</p>
<p>易验证$R^X$是$R$上的一个线性空间。（函数空间，微积分研究的就是函数空间。）</p>
<h2 id="线性空间的性质"><a href="#线性空间的性质" class="headerlink" title="线性空间的性质"></a>线性空间的性质</h2><p>设$V$是数域$k$上的一个线性空间</p>
<p>1.零元素唯一</p>
<p>2.负元素唯一</p>
<p>3.$0 \alpha =0$</p>
<p>4.$k0 = 0$</p>
<p>5.假设$k\alpha = 0$,则$k=0$,或者$\alpha=0$</p>
<p>6.$(-1)\alpha = -\alpha$</p>
<h2 id="线性子空间"><a href="#线性子空间" class="headerlink" title="线性子空间"></a>线性子空间</h2><p><strong>定义</strong>：设$V$是数域$K$上的一个线性空间，$U$是$V$的一个非空子集，如果$U$对于$V$的加法和数量乘法也成为数域$K$上的一个线性空间，那么$U$是$V$的一个<font color="red">线性子空间</font>。</p>
<p>$V$的非空子集$U$是子空间$\Longleftrightarrow$</p>
<p>(1)若$\alpha,\beta \in U$,则$\alpha + \beta \in U \quad$($U$对于$V$的加法封闭)</p>
<p>(2)若$\alpha \in U,k \in K$,则$k\alpha \in U \quad$($U$对于$V$的数量乘法封闭)</p>
<p>定理：如果线性空间$V$的一个非空集合$W$对于$V$的两种运算封闭，那么$W$是一个子空间。</p>
<h3 id="生成子空间"><a href="#生成子空间" class="headerlink" title="生成子空间"></a>生成子空间</h3><p>令$W=\begin{Bmatrix}k_1\alpha_1+k_2\alpha_2+…+k_s\alpha_s|k_1,…,k_s \in K\end{Bmatrix},0 \in W$,易验证W对于V的加法和数量乘法封闭，因此W是V的一个子空间，称它是由向量组$\alpha_1,\alpha_2,…,\alpha_s$<font color="red">生成的子空间</font>，记作$L(\alpha_1,…,\alpha_s)$或者$&lt;\alpha_1,…,\alpha_s&gt;$。</p>
<p>$\beta \in L(\alpha_1,\alpha_2,…,\alpha_s) \Longleftrightarrow$$K$中存在一组数$k_1,k_2,…,k_s$使得$\beta=k_1\alpha_1+k_2\alpha_2+…+k_s\alpha_s$,此时称$\beta$可以由向量组$\alpha_1.\alpha_2,…,\alpha_s$<font color="red">线性表出</font>。</p>
<p>因此，对于方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
a_{11}x_1 + a_{12}x_2 + ... +a_{1n}x_n = b_1, \\\\
a_{21}x_1 + a_{22}x_2 + ... +a_{2n}x_n = b_2, \\\\
\quad\quad\quad\quad\quad\quad....\\\\
a_{s1}x_1 + a_{s2}x_2 + ... +a_{sn}x_n = b_s. 
\end{cases}</script><p>即$x_1\alpha_1+…+x_n\alpha_n=\beta$有解</p>
<p>$\Longleftrightarrow$$K$中有一组数$c_1,…,c_n$使得$c_1\alpha_1+…+c_n\alpha_n=\beta$</p>
<p>$\Longleftrightarrow \beta$可以由向量组$\alpha_1,…,\alpha_n$线性表出</p>
<p>$\Longleftrightarrow \beta \in L(\alpha_1,…,\alpha_n)$</p>
<h2 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h2><p><strong>定义</strong>：设$V$是数域$K$上的一个线性空间，$V$中的一个向量组$\alpha_1,\alpha_2,…,\alpha_s(s \geq 1)$，如果$K$中<strong>不全为0的数</strong>$k_1,k_2,…,k_s$，使得$k_1\alpha_1+k_2\alpha_2+…+k_s\alpha_s=0$，那么称$\alpha_1,\alpha_2,…,\alpha_s$<strong>线性相关</strong>；否则，称$\alpha_1,\alpha_2,…,\alpha_s$<strong>线性无关</strong>。</p>
<hr>
<p>$K^s$中，列向量组$\alpha_1,\alpha_2,…,\alpha_n$线性相关</p>
<p>$\Longleftrightarrow K$中又不全为0的数$c_1,…,c_n$使得$c_1\alpha_1+c_2\alpha_2+…+c_n\alpha_n=0$</p>
<p>$\Longleftrightarrow K$上n元齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=0$有非零解。</p>
<p>$\Longleftrightarrow$以$\alpha_1,\alpha_2,…,\alpha_n$为列向量组的矩阵$A$的行列式等于0</p>
<p>$K^s$中，列向量组$\alpha_1,\alpha_2,…,\alpha_n$线性无关</p>
<p>$\Longleftrightarrow K$上n元齐次线性方程组$x_1\alpha_1+…+x_n\alpha_n=0$只有零解。</p>
<p>$\Longleftrightarrow$以$\alpha_1,\alpha_2,…,\alpha_n$为列向量组的矩阵$A$的行列式不等于0</p>
<hr>
<p>设$\beta$可以由$\alpha_1,\alpha_2,…,\alpha_s$线性表出，则表出方式唯一$\Longleftrightarrow \alpha_1,\alpha_2,…,\alpha_n$线性无关。</p>
<p>$\Longleftrightarrow AX=b$有唯一解</p>
<p>设$\alpha_1,\alpha_2,…,\alpha_s$线性无关，如果$\alpha_1,\alpha_2,…,\alpha_s,\beta$线性相关，那么$\beta$可以由$\alpha_1,\alpha_2,…,\alpha_s$线性表出。</p>
<hr>
<h3 id="极大线性无关组"><a href="#极大线性无关组" class="headerlink" title="极大线性无关组"></a>极大线性无关组</h3><p><strong>定义</strong>：向量组$\alpha_1,\alpha_2,…,\alpha_s$的一个部分组如果满足：(1)这个部分组线性无关;(2)从向量组的其余向量（如果有的话）中任取一个添进来，得到的新的部分组线性相关。则称这个部分组为这个向量组的一个极大线性无关组。</p>
<p>若向量组$\alpha_1,\alpha_2,…,\alpha_s$与向量组$\beta_1,\beta_2,…,\beta_r$可以互相线性表出，则称这两个向量组<strong>等价</strong>。</p>
<p>向量组$\alpha_1,\alpha_2,…,\alpha_s$与它的任意一个极大线性无关组等价。</p>
<p>向量组的等价具有以下性质：</p>
<p>(1)每个向量组与自身等价(反身性)</p>
<p>(2)若$\begin{Bmatrix}\alpha_1,…,\alpha_s\end{Bmatrix} \cong \begin{Bmatrix}\beta_1,…,\beta_r\end{Bmatrix}$,则$\begin{Bmatrix}\beta_1,…,\beta_r\end{Bmatrix} \cong \begin{Bmatrix}\alpha_1,…,\alpha_s\end{Bmatrix}$(对称性)</p>
<p>(3)若<br>$\begin{Bmatrix}\alpha_1,…,\alpha_s\end{Bmatrix} \cong \begin{Bmatrix}\beta_1,…,\beta_r\end{Bmatrix}$,<br>$\begin{Bmatrix}\beta_1,…,\beta_r\end{Bmatrix} \cong \begin{Bmatrix}\gamma_1,…,\gamma_t\end{Bmatrix}$<br>则$\begin{Bmatrix}\alpha_1,…,\alpha_s\end{Bmatrix} \cong \begin{Bmatrix}\gamma_1,…,\gamma_t\end{Bmatrix}$(传递性)</p>
<p>向量组的任意两个极大线性无关组等价。</p>
<hr>
<p><strong>引理</strong>：设向量组$\beta_1,…,\beta_r$可由向量组$\alpha_1,\alpha_2,…,\alpha_s$线性表出。如果$r&gt;s$，那么$\beta_1,…,\beta_r$一定线性相关。</p>
<p>证明：由已知</p>
<script type="math/tex; mode=display">
\begin{cases}
\beta_1 = a_{11}\alpha_1+...+a_{s1}\alpha_s,\\\\
\quad\quad\quad...\\\\
\beta_r = a_{1r}\alpha_1+...+a_{sr}\alpha_s
\end{cases}</script><p>$\begin{aligned}<br>x_1\beta_1+…+x_r\beta_r &amp;=<br>x_1(a_{11}\alpha_1+…+a_{s1}\alpha_s)<br>+….+<br>x_r(a_{1r}\alpha_1+…+a_{sr}\alpha_s)\\\\<br>&amp;=(x_1a_{11}+…+x_ra_{1r})\alpha_1<br>+…+<br>(x_1a_{s1}+…+x_ra_{sr})\alpha_s\\\\<br>&amp;=0<br>\end{aligned}$</p>
<p>考虑齐次线性方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1a_{11}+...+x_ra_{1r}=0\\\\
\quad\quad...\\\\
x_1a_{s1}+...+x_ra_{sr}=0
\end{cases}
\quad(1)</script><p>由$r&gt;s$，齐次线性方程组(1)有非零解$(k_1,…,k_r)$。因此$k_1\beta_1+…+k_r\beta_r=0$，故$\beta_1,…,\beta_r$线性相关。</p>
<hr>
<p><strong>推论1</strong>：设向量组$\beta_1,…,\beta_r$可以由向量组$\alpha_1,…,\alpha_s$线性表出，如果$\beta_1,..,\beta_r$线性无关，则$r \leq s$。</p>
<p><strong>推论2</strong>：等价的线性无关的两个向量组所含向量的个数相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">A--&gt;B;</span><br><span class="line">A--&gt;C;</span><br><span class="line">B--&gt;D;</span><br><span class="line">C--&gt;D;</span><br></pre></td></tr></table></figure>
<h2 id="线性空间的结构"><a href="#线性空间的结构" class="headerlink" title="线性空间的结构"></a>线性空间的结构</h2><h2 id="线性空间的度量"><a href="#线性空间的度量" class="headerlink" title="线性空间的度量"></a>线性空间的度量</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2020/02/09/线性方程组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/09/线性方程组/" itemprop="url">线性方程组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-09T00:00:00+08:00">
                2020-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线性方程组/" itemprop="url" rel="index">
                    <span itemprop="name">线性方程组</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="消元法解线性方程组"><a href="#消元法解线性方程组" class="headerlink" title="消元法解线性方程组"></a>消元法解线性方程组</h1><p>对于一般线性方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
a_{11}x_1 + a_{12}x_2 + ... +a_{1n}x_n = b_1, \\\\
a_{21}x_1 + a_{22}x_2 + ... +a_{2n}x_n = b_2, \\\\
....\\\\
a_{s1}x_1 + a_{s2}x_2 + ... +a_{sn}x_n = b_s. 
\end{cases}</script><p>其中$x_1,x_2,…,x_n$代表$n$个未知量，$a_{ij}$为方程组的系数，$b_i$为常数项。</p>
<p>方程组可以用以下矩阵表示</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
a_{11} & a_{12} & ... & a_{1n} & b_1 \\\\
a_{21} & a_{22} & ... & a_{2n} & b_2 \\\\
... & ... & ... & ... & ... \\\\
a_{s1} & a_{s2} & ... & a_{sn} & b_n
\end{pmatrix}</script><h1 id="n维向量及n为向量空间"><a href="#n维向量及n为向量空间" class="headerlink" title="n维向量及n为向量空间"></a>n维向量及n为向量空间</h1><h1 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h1><h1 id="线性方程组解的存在与结构"><a href="#线性方程组解的存在与结构" class="headerlink" title="线性方程组解的存在与结构"></a>线性方程组解的存在与结构</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2020/02/05/timu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/05/timu/" itemprop="url">行列式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-05T00:00:00+08:00">
                2020-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/行列式/" itemprop="url" rel="index">
                    <span itemprop="name">行列式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算行列式</p>
<script type="math/tex; mode=display">
D_n = 
\begin{vmatrix}
1+x_1 & 1+x^2_1 & ... & 1+x^n_1 \\\\
1+x_2 & 1+x^2_2 & ... & 1+x^n_2 \\\\
... & ... & ... & ... \\\\
1+x_n & 1+x^2_n & ... & 1+x^n_n
\end{vmatrix}</script><p>先加边，得</p>
<script type="math/tex; mode=display">
D_n = 
\begin{vmatrix}
1 & 0 & 0 & ... & 0 \\\\
1 & 1+x_1 & 1+x^2_1 & ... & 1+x^n_1 \\\\
1 & 1+x_2 & 1+x^2_2 & ... & 1+x^n_2 \\\\
.... & .... &... & ... & ... \\\\
1 & 1+x_n & 1+x^2_n & ... & 1+x^n_n 
\end{vmatrix}

=\begin{vmatrix}
1 & -1 & -1 & ... & -1 \\\\
1 & x_1 & x^2_1 & ... & x^n_1 \\\\
1 & x_2 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... & ... \\\\
1 & x_n & x^2_n & ... & x^n_n
\end{vmatrix}</script><p>按第一行展开</p>
<script type="math/tex; mode=display">
=\begin{vmatrix}
x_1 & x^2_1 & ... & x^n_1 \\\\
x_2 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... \\\\
x_n & x^2_n & ... & x^n_n
\end{vmatrix}

+(-1)^4
\begin{vmatrix}
1& x^2_1 & ... & x^n_1 \\\\
1 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... \\\\
1 & x^2_n & ... & x^n_n
\end{vmatrix}

+...

+(-1)^{n+3}
\begin{vmatrix}
1& x_1 &  ... & x^{n-1}_1 \\\\
1 & x_2 & ... & x^{n-1}_2 \\\\
... & ... & ... & ... \\\\
1 & x_n & ... & x^{n-1}_n
\end{vmatrix}</script><p>而</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
x_1 & x^2_1 & ... & x^n_1 \\\\
x_2 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... \\\\
x_n & x^2_n & ... & x^n_n
\end{vmatrix}
=x_1x_2...x_n
\begin{vmatrix}
1 & x_1 & ... & x^{n-1}_1 \\\\
1 & x_2 & ... & x^{n-1}_2 \\\\
... & ... & ... & ... \\\\
1 & x_n & ... & x^{n-1}_n
\end{vmatrix}
=x_1x_2...x_n\prod_{1 \leq i < j \leq n}(x_j-x_i)</script><p>又令</p>
<script type="math/tex; mode=display">
A_1=
\begin{vmatrix}
1& x^2_1 & ... & x^n_1 \\\\
1 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... \\\\
1 & x^2_n & ... & x^n_n
\end{vmatrix}
 \quad ... \quad
A_n = 
\begin{vmatrix}
1& x_1 &  ... & x^{n-1}_1 \\\\
1 & x_2 & ... & x^{n-1}_2 \\\\
... & ... & ... & ... \\\\
1 & x_n & ... & x^{n-1}_n
\end{vmatrix}</script><p>将$A_1$添加一个变量$x_{n+1}$得</p>
<script type="math/tex; mode=display">
B=
\begin{vmatrix}
1& x_1 & x^2_1 & ... & x^n_1 \\\\
1 & x_2 & x^2_2 & ... & x^n_2 \\\\
... & ... & ... & ... & ... \\\\
1 & x_n & x^2_n & ... & x^n_n \\\\
1 & x_{n+1} & x^2_{n+1} & ... & x^n_{n+1}
\end{vmatrix}
=\prod_{1 \leq i < j \leq n+1}(x_j-x_i)</script><p>而$A_1$是$B$按第$n+1$行展开的展开式中$x_{n+1}$的系数的$(-1)^{n+1+2}$倍</p>
<p>$x_{n+1}$的系数为$(-1)^{n-1}(x_1x_2…x_{n-1}+x_2x_3…x_{n-2}x_n+…+x_2x_3…x_n) \prod_{1 \leq i &lt; j \leq n}(x_j-x_i)$</p>
<p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_1&=(-1)^{n+1+2}(-1)^{n-1}(x_1x_2...x_{n-1}+x_2x_3...x_{n-2}x_n+...+x_2x_3...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i) \\
=&(x_1x_2...x_{n-1}+x_2x_3...x_{n-2}x_n+...+x_2x_3...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i)
\end{aligned}</script><p>同理可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_2=&(x_1x_2...x_{n-2}+x_2x_3...x_{n-3}x_n+...+x_3x_4...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i) \\
A_3=&(x_1x_2...x_{n-3}+x_2x_3...x_{n-4}x_n+...+x_4x_5...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i) \\
... \\
A_{n-1}&=(x_1+x_2+...+x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i) \\
A_n&=\prod_{1 \leq i < j \leq n}(x_j-x_i)
\end{aligned}</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
D_n = x_1x_2...x_n\prod_{1 \leq i < j \leq n}(x_j-x_i)+\\
(-1)^4(x_1x_2...x_{n-1}+x_2x_3...x_{n-2}x_n+...+x_2x_3...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i)+ \\
(-1)^5(x_1x_2...x_{n-2}+x_2x_3...x_{n-3}x_n+...+x_3x_4...x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i)+\\
...\\
(-1)^{n+2}(x_1+x_2+...+x_n) \prod_{1 \leq i < j \leq n}(x_j-x_i)+\\
(-1)^{n+3}\prod_{1 \leq i < j \leq n}(x_j-x_i) \\
=(2\prod_{i=1}^nx_i-\prod_{i=1}^n(x_i-1))\prod_{1 \leq i < j \leq n}(x_j-x_i)
\end{aligned}</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2020/02/02/数列递推/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/02/数列递推/" itemprop="url">数列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-02T00:00:00+08:00">
                2020-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数列/" itemprop="url" rel="index">
                    <span itemprop="name">数列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="特征根求数列通项公式"><a href="#特征根求数列通项公式" class="headerlink" title="特征根求数列通项公式"></a>特征根求数列通项公式</h1><h2 id="a-1-b-a-n-1-ca-n-d-通项公式求法"><a href="#a-1-b-a-n-1-ca-n-d-通项公式求法" class="headerlink" title="$a_1=b,a_{n+1} = ca_n+d,$通项公式求法"></a>$a_1=b,a_{n+1} = ca_n+d,$通项公式求法</h2><p><strong><font color="red">不动点法</font></strong></p>
<p>显然数列的极限是方程$x = cx+d$的一个根，这个方程也是映射$f(x) = cx+d$的不动点。</p>
<p>显然方程的根为$x_0=\frac{d}{1-c}$,则有</p>
<script type="math/tex; mode=display">
a_{n+1}-x_0=ca_n+d-x_0</script><p>将$x_0=\frac{d}{1-c}$代入得</p>
<script type="math/tex; mode=display">
a_{n+1}-\frac{d}{1-c} = ca_n+d-\frac{d}{1-c}</script><p>得到</p>
<script type="math/tex; mode=display">
a_{n+1}-\frac{d}{1-c} = c(a_n-\frac{d}{1-c})</script><p>现讨论以下情况：</p>
<hr>
<p><strong>1.当$x_0=a_1$时</strong></p>
<p>数列$\{a_n-\frac{d}{1-c}\}$是0数列，故$a_n=a_1$</p>
<p><strong>2.当$x_0 \neq a_1$时</strong></p>
<p>数列$\{a_n-\frac{d}{1-c}\}$是以$c$为公比，$a_1-\frac{d}{1-c}$为首项的等比数列，故$a_n=(a_1-\frac{d}{1-c})c^{n-1}+\frac{d}{1-c}$</p>
<hr>
<h2 id="a-1-alpha-a-2-beta-a-n-2-pa-n-1-qa-通项公式求法"><a href="#a-1-alpha-a-2-beta-a-n-2-pa-n-1-qa-通项公式求法" class="headerlink" title="$a_1=\alpha,a_2=\beta,a_{n+2}=pa_{n+1}+qa_,$通项公式求法"></a>$a_1=\alpha,a_2=\beta,a_{n+2}=pa_{n+1}+qa_,$通项公式求法</h2><p>建立特征方程$x^2-px-q=0$，其中$x_!+x_2=p,x_1x_2=-q$</p>
<p>则有</p>
<script type="math/tex; mode=display">
a_{n+2}-x_1a_{n+1} = x_2(a_{n+1}-x_1a_n)</script><script type="math/tex; mode=display">
a_{n+2}-x_2a_{n+1} = x_1(a_{n+1}-x_2a_n)</script><p>现讨论以下情况：</p>
<hr>
<p><strong>1.当$x_1=x_2$时</strong></p>
<script type="math/tex; mode=display">
a_{n}-x_1a_{n-1}=(a_{2}-x_1a_1)x^{n-2}_1</script><p>得到</p>
<script type="math/tex; mode=display">
\frac{a_n}{x^n_1} = \frac{a_{n-1}}{x^{n-1}_1} + A</script><p>得到</p>
<script type="math/tex; mode=display">
a_n = (B+nC)x^{n-1}_1</script><p>代入$a_1,a_2$得</p>
<script type="math/tex; mode=display">
\begin{cases}
\alpha = B + C \\\\
\beta = (B+2C)x_1
\end{cases}</script><p>解出$B,C$，最终得到$a_n$</p>
<p><strong>2.当$x_1 \neq x_2$时</strong></p>
<script type="math/tex; mode=display">
\begin{cases}
a_{n}-x_1a_{n-1}=(a_{2}-x_1a_1)x^{n-2}_2 \\\\
a_{n}-x_2a_{n-1}=(a_{2}-x_2a_1)x^{n-2}_1
\end{cases}</script><p>得到</p>
<script type="math/tex; mode=display">
a_n = Ax^{n-1}_1 + Bx^{n-1}_2,</script><p>(其中$A,B$由$\alpha,\beta$决定)</p>
<p>代入$a_1,a_2$得</p>
<script type="math/tex; mode=display">
\begin{cases}
\alpha = A + B \\\\
\beta = Ax_1 + Bx_2
\end{cases}</script><p>解出$B,C$，最终得到$a_n$</p>
<hr>
<h2 id="a-n-1-frac-Aa-n-B-Ca-n-D-C-neq-0-AD-neq-BC-通项公式求法"><a href="#a-n-1-frac-Aa-n-B-Ca-n-D-C-neq-0-AD-neq-BC-通项公式求法" class="headerlink" title="$a_{n+1} = \frac{Aa_n + B}{Ca_n + D},C \neq 0,AD \neq BC,$通项公式求法"></a>$a_{n+1} = \frac{Aa_n + B}{Ca_n + D},C \neq 0,AD \neq BC,$通项公式求法</h2><p>显然这个数列的极限是方程$\lambda = \frac{A\lambda+B}{C\lambda+D}$的一个根，这个方程的根其实就是映射$f(\lambda)=\frac{A\lambda+B}{C\lambda+D}$的不动点。</p>
<p>假设方程$\lambda = \frac{A\lambda+B}{C\lambda+D}$的两个根分别为$\alpha,\beta$,则</p>
<script type="math/tex; mode=display">
a_{n+1} - \alpha = \frac{Aa_n + B}{Ca_n + D} - \alpha=\frac{(a_n - \alpha)(A - C\alpha)}{Ca_n + D}</script><p>两边取倒数，得到</p>
<script type="math/tex; mode=display">
\frac{1}{a_{n+1} - \alpha} = \frac{Ca_n + D}{(a_n - \alpha)(A-C\alpha)}=\frac{C}{A-C\alpha}+\frac{C\alpha + D}{A-C\alpha}\frac{1}{a_n - \alpha}</script><p>显然$\begin{Bmatrix}\frac{1}{a_n - \alpha}\end{Bmatrix}$是一个一阶常系数非齐次线性递推数列。</p>
<p>现讨论以下情况</p>
<hr>
<p><strong>1.$\alpha=\beta$时</strong></p>
<p>此时$\alpha = \frac{A-D}{2C},\frac{C\alpha+D}{A-C\alpha} = 1$,因此$\begin{Bmatrix}\frac{1}{a_n - \alpha}\end{Bmatrix}$是个公差为$\frac{C}{A-C\alpha}$的等差数列</p>
<p><strong>2.$\alpha \neq \beta$时</strong></p>
<p>此时$\frac{a_{n+1} - \alpha}{a_{n+1} - \beta} = \frac{A - C\alpha}{A - C\beta}\frac{a_n - \alpha}{a_n - \beta}$,即$\begin{Bmatrix}\frac{a_n - \alpha}{a_n - \beta}\end{Bmatrix}$是公比为$\frac{A - C\alpha}{A - C\beta}$的等比数列</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/numpy知识点梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/numpy知识点梳理/" itemprop="url">numpy知识点梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/numpy/" itemprop="url" rel="index">
                    <span itemprop="name">numpy</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Numpy相关知识点"><a href="#Numpy相关知识点" class="headerlink" title="Numpy相关知识点"></a>Numpy相关知识点</h1><hr>
<h2 id="numpy中的矩阵和向量"><a href="#numpy中的矩阵和向量" class="headerlink" title="numpy中的矩阵和向量"></a>numpy中的矩阵和向量</h2><h3 id="矩阵与向量的创建与索引"><a href="#矩阵与向量的创建与索引" class="headerlink" title="矩阵与向量的创建与索引"></a>矩阵与向量的创建与索引</h3><h4 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h4><pre><code>要在numpy中构造矩阵，我们在列表中列出矩阵的行，并将该列表传递给numpy数组构造函数。
A = np.array([[1,-1,2],[3,2,0]])
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>-1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h4><pre><code>向量只是具有单列的数组。 
v = np.array([[2],[1],[3]])
更方便的方法是转置相应的行向量。 例如，为了使上面的矢量，我们可以改为转置行向量
v = np.transpose(np.array([[2,1,3]]))
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
</tr>
<tr>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code>numpy重载数组索引和切片符号以访问矩阵的各个部分
A[1,2]

要切出A矩阵中的第二列
A[:,1:2]
第一个切片选择A中的所有行，而第二个切片仅选择每行中的中间条目。

要进行矩阵乘法或矩阵向量乘法，我们使用np.dot()方法。
np.dot(A,v)
</code></pre><h2 id="用numpy求解方程组"><a href="#用numpy求解方程组" class="headerlink" title="用numpy求解方程组"></a>用numpy求解方程组</h2><pre><code>线性代数中比较常见的问题之一是求解矩阵向量方程。 这是一个例子。 我们寻找解决方程的向量x
A x = b
A = np.array([[2,1,-2],[3,0,1],[1,1,-1]])
b = np.transpose(np.array([[-3,5,-2]])）
x = np.linalg.solve(A,b)
</code></pre><h2 id="数据分析练习"><a href="#数据分析练习" class="headerlink" title="数据分析练习"></a>数据分析练习</h2><h3 id="如何创建一个布尔数组"><a href="#如何创建一个布尔数组" class="headerlink" title="如何创建一个布尔数组"></a>如何创建一个布尔数组</h3><pre><code>创建一个numpy数组元素值全为True（真）的数组
np.full((3, 3), True, dtype=bool)
&gt;&gt; array([[ True,  True,  True],
        [ True,  True,  True],
        [ True,  True,  True]], dtype=bool)

np.ones((3,3), dtype=bool)
</code></pre><h3 id="如何从一维数组中提取满足指定条件的元素"><a href="#如何从一维数组中提取满足指定条件的元素" class="headerlink" title="如何从一维数组中提取满足指定条件的元素"></a>如何从一维数组中提取满足指定条件的元素</h3><pre><code>从 arr 中提取所有的奇数
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[arr % 2 == 1]
&gt;&gt;array([1, 3, 5, 7, 9])
</code></pre><h3 id="如何用numpy数组中的另一个值替换满足条件的元素项"><a href="#如何用numpy数组中的另一个值替换满足条件的元素项" class="headerlink" title="如何用numpy数组中的另一个值替换满足条件的元素项"></a>如何用numpy数组中的另一个值替换满足条件的元素项</h3><pre><code>将arr中的所有奇数替换为-1
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[arr % 2 == 1] = -1
print(arr)
&gt;&gt;array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])
</code></pre><h3 id="如何在不影响原始数组的情况下替换满足条件的元素项"><a href="#如何在不影响原始数组的情况下替换满足条件的元素项" class="headerlink" title="如何在不影响原始数组的情况下替换满足条件的元素项"></a>如何在不影响原始数组的情况下替换满足条件的元素项</h3><pre><code>将arr中的所有奇数替换为-1，而不改变arr
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
out = np.where(arr % 2 == 1, -1, arr)
print(out)
&gt;&gt;array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])
</code></pre><h3 id="如何改变数组的形状"><a href="#如何改变数组的形状" class="headerlink" title="如何改变数组的形状"></a>如何改变数组的形状</h3><pre><code>将一维数组转换为2行的2维数组
arr = np.arange(10)
arr.reshape(2, -1) #Setting to -1 automatically decides the number of cols
</code></pre><h3 id="如何垂直叠加两个数组"><a href="#如何垂直叠加两个数组" class="headerlink" title="如何垂直叠加两个数组"></a>如何垂直叠加两个数组</h3><pre><code>垂直堆叠数组a和数组b
a = np.arange(10).reshape(2,-1)
b = np.repeat(1, 10).reshape(2,-1)
# Method 1:
np.concatenate([a, b], axis=0)
# Method 2:
np.vstack([a, b])
# Method 3:
np.r_[a, b]

&gt;&gt; array([[0, 1, 2, 3, 4],
         [5, 6, 7, 8, 9],
         [1, 1, 1, 1, 1],
         [1, 1, 1, 1, 1]])
</code></pre><h3 id="如何水平叠加两个数组"><a href="#如何水平叠加两个数组" class="headerlink" title="如何水平叠加两个数组"></a>如何水平叠加两个数组</h3><pre><code>将数组a和数组b水平堆叠
a = np.arange(10).reshape(2,-1)
b = np.repeat(1, 10).reshape(2,-1)
# Method 1:
np.concatenate([a, b], axis=1)
# Method 2:
np.hstack([a, b])
# Method 3:
np.c_[a, b]
&gt;&gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],
        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])
</code></pre><h3 id="如何在无硬编码的情况下生成numpy中的自定义序列"><a href="#如何在无硬编码的情况下生成numpy中的自定义序列" class="headerlink" title="如何在无硬编码的情况下生成numpy中的自定义序列"></a>如何在无硬编码的情况下生成numpy中的自定义序列</h3><pre><code>创建以下模式而不使用硬编码。只使用numpy函数和下面的输入数组a
a = np.array([1,2,3])`
np.r_[np.repeat(a, 3), np.tile(a, 3)]
&gt;&gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])
</code></pre><h3 id="如何获取两个numpy数组之间的公共项"><a href="#如何获取两个numpy数组之间的公共项" class="headerlink" title="如何获取两个numpy数组之间的公共项"></a>如何获取两个numpy数组之间的公共项</h3><pre><code>获取数组a和数组b之间的公共项
a = np.array([1,2,3,2,3,4,3,4,5,6])
b = np.array([7,2,10,2,7,4,9,4,9,8])
np.intersect1d(a,b)
&gt;&gt; array([2, 4])
</code></pre><h3 id="如何从一个数组中删除存在于另一个数组中的项"><a href="#如何从一个数组中删除存在于另一个数组中的项" class="headerlink" title="如何从一个数组中删除存在于另一个数组中的项"></a>如何从一个数组中删除存在于另一个数组中的项</h3><pre><code>从数组a中删除数组b中的所有项
a = np.array([1,2,3,4,5])
b = np.array([5,6,7,8,9])

# From &#39;a&#39; remove all of &#39;b&#39;
np.setdiff1d(a,b)
&gt;&gt; array([1, 2, 3, 4])
</code></pre><h3 id="如何得到两个数组元素匹配的位置"><a href="#如何得到两个数组元素匹配的位置" class="headerlink" title="如何得到两个数组元素匹配的位置"></a>如何得到两个数组元素匹配的位置</h3><pre><code>a = np.array([1,2,3,2,3,4,3,4,5,6])
b = np.array([7,2,10,2,7,4,9,4,9,8])

np.where(a == b)
&gt;&gt; (array([1, 3, 5, 7]),)
</code></pre><h3 id="如何从numpy数组中提取给定范围内的所有数字"><a href="#如何从numpy数组中提取给定范围内的所有数字" class="headerlink" title="如何从numpy数组中提取给定范围内的所有数字"></a>如何从numpy数组中提取给定范围内的所有数字</h3><pre><code>获取5到10之间的所有项目
a = np.arange(15)
# Method 1
index = np.where((a &gt;= 5) &amp; (a &lt;= 10))
a[index]
# Method 2:
index = np.where(np.logical_and(a&gt;=5, a&lt;=10))
a[index]
&gt;&gt; (array([6, 9, 10]),)
# Method 3: (thanks loganzk!)
a[(a &gt;= 5) &amp; (a &lt;= 10)]
</code></pre><h3 id="如何创建一个python函数来处理scalars并在numpy数组上工作"><a href="#如何创建一个python函数来处理scalars并在numpy数组上工作" class="headerlink" title="如何创建一个python函数来处理scalars并在numpy数组上工作"></a>如何创建一个python函数来处理scalars并在numpy数组上工作</h3><pre><code>def maxx(x, y):
&quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;
if x &gt;= y:
    return x
else:
    return y

pair_max = np.vectorize(maxx, otypes=[float])

a = np.array([5, 7, 9, 8, 6, 4, 5])
b = np.array([6, 3, 4, 8, 9, 7, 1])

pair_max(a, b)
&gt;&gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])
</code></pre><h3 id="如何交换二维numpy数组中的两列"><a href="#如何交换二维numpy数组中的两列" class="headerlink" title="如何交换二维numpy数组中的两列"></a>如何交换二维numpy数组中的两列</h3><pre><code>在数组arr中交换列1和2
# Input
arr = np.arange(9).reshape(3,3)
arr

# Solution
arr[:, [1,0,2]]
&gt;&gt; array([[1, 0, 2],
        [4, 3, 5],
        [7, 6, 8]])
</code></pre><h3 id="如何交换二维numpy数组中的两行"><a href="#如何交换二维numpy数组中的两行" class="headerlink" title="如何交换二维numpy数组中的两行"></a>如何交换二维numpy数组中的两行</h3><pre><code>交换数组arr中的第1和第2行
# Input
arr = np.arange(9).reshape(3,3)

# Solution
arr[[1,0,2], :]
&gt;&gt; array([[3, 4, 5],
        [0, 1, 2],
        [6, 7, 8]])
</code></pre><h3 id="如何反转二维数组的行"><a href="#如何反转二维数组的行" class="headerlink" title="如何反转二维数组的行"></a>如何反转二维数组的行</h3><pre><code>反转二维数组arr的行
# Input
arr = np.arange(9).reshape(3,3)
# Solution
arr[::-1]
&gt;&gt;array([[6, 7, 8],
       [3, 4, 5],
       [0, 1, 2]])
</code></pre><h3 id="如何反转二维数组的列"><a href="#如何反转二维数组的列" class="headerlink" title="如何反转二维数组的列"></a>如何反转二维数组的列</h3><pre><code># Input
arr = np.arange(9).reshape(3,3)

# Solution
arr[:, ::-1]
&gt;&gt; array([[2, 1, 0],
        [5, 4, 3],
        [8, 7, 6]])
</code></pre><h3 id="如何创建包含5到10之间随机浮动的二维数组"><a href="#如何创建包含5到10之间随机浮动的二维数组" class="headerlink" title="如何创建包含5到10之间随机浮动的二维数组"></a>如何创建包含5到10之间随机浮动的二维数组</h3><pre><code>创建一个形状为5x3的二维数组，以包含5到10之间的随机十进制数
# Input
arr = np.arange(9).reshape(3,3)

# Solution Method 1:
rand_arr = np.random.randint(low=5, high=10, size=(5,3)) + np.random.random((5,3))
# print(rand_arr)

# Solution Method 2:
rand_arr = np.random.uniform(5,10, size=(5,3))
print(rand_arr)
# &gt; [[ 8.50061025  9.10531502  6.85867783]
# &gt;  [ 9.76262069  9.87717411  7.13466701]
# &gt;  [ 7.48966403  8.33409158  6.16808631]
# &gt;  [ 7.75010551  9.94535696  5.27373226]
# &gt;  [ 8.0850361   5.56165518  7.31244004]]
</code></pre><h3 id="如何在numpy数组中只打印小数点后三位"><a href="#如何在numpy数组中只打印小数点后三位" class="headerlink" title="如何在numpy数组中只打印小数点后三位"></a>如何在numpy数组中只打印小数点后三位</h3><pre><code>只打印或显示numpy数组rand_arr的小数点后3位
# Input
rand_arr = np.random.random((5,3))

# Create the random array
rand_arr = np.random.random([5,3])

# Limit to 3 decimal places
np.set_printoptions(precision=3)
rand_arr[:4]
# &gt; array([[ 0.443,  0.109,  0.97 ],
# &gt;        [ 0.388,  0.447,  0.191],
# &gt;        [ 0.891,  0.474,  0.212],
# &gt;        [ 0.609,  0.518,  0.403]])
</code></pre><h3 id="如何通过e式科学记数法（如1e10）来打印一个numpy数组"><a href="#如何通过e式科学记数法（如1e10）来打印一个numpy数组" class="headerlink" title="如何通过e式科学记数法（如1e10）来打印一个numpy数组"></a>如何通过e式科学记数法（如1e10）来打印一个numpy数组</h3><pre><code>通过e式科学记数法来打印rand_arr（如1e10）
# Reset printoptions to default
np.set_printoptions(suppress=False)

# Create the random array
np.random.seed(100)
rand_arr = np.random.random([3,3])/1e3
rand_arr
# &gt; array([[  5.434049e-04,   2.783694e-04,   4.245176e-04],
# &gt;        [  8.447761e-04,   4.718856e-06,   1.215691e-04],
# &gt;        [  6.707491e-04,   8.258528e-04,   1.367066e-04]])
np.set_printoptions(suppress=True, precision=6)  # precision is optional
rand_arr
# &gt; array([[ 0.000543,  0.000278,  0.000425],
# &gt;        [ 0.000845,  0.000005,  0.000122],
# &gt;        [ 0.000671,  0.000826,  0.000137]])
</code></pre><h3 id="如何限制numpy数组输出中打印的项目数"><a href="#如何限制numpy数组输出中打印的项目数" class="headerlink" title="如何限制numpy数组输出中打印的项目数"></a>如何限制numpy数组输出中打印的项目数</h3><pre><code>将numpy数组a中打印的项数限制为最多6个元素
np.set_printoptions(threshold=6)
a = np.arange(15)
a
# &gt; array([ 0,  1,  2, ..., 12, 13, 14])
</code></pre><h3 id="如何打印完整的numpy数组而不截断"><a href="#如何打印完整的numpy数组而不截断" class="headerlink" title="如何打印完整的numpy数组而不截断"></a>如何打印完整的numpy数组而不截断</h3><pre><code>打印完整的numpy数组a而不截断
# Input
np.set_printoptions(threshold=6)
a = np.arange(15)

# Solution
np.set_printoptions(threshold=np.nan)
a
# &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre><h3 id="如何导入数字和文本的数据集保持文本在numpy数组中完好无损"><a href="#如何导入数字和文本的数据集保持文本在numpy数组中完好无损" class="headerlink" title="如何导入数字和文本的数据集保持文本在numpy数组中完好无损"></a>如何导入数字和文本的数据集保持文本在numpy数组中完好无损</h3><pre><code>导入鸢尾属植物数据集，保持文本不变
# Solution
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)

# Print the first 3 rows
iris[:3]
# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],
# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;],
# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;]], dtype=object)
</code></pre><h3 id="如何从1维元组数组中提取特定列"><a href="#如何从1维元组数组中提取特定列" class="headerlink" title="如何从1维元组数组中提取特定列"></a>如何从1维元组数组中提取特定列</h3><pre><code>从前面问题中导入的一维鸢尾属植物数据集中提取文本列的物种
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)
print(iris_1d.shape)

# Solution:
species = np.array([row[4] for row in iris_1d])
species[:5]
# &gt; (150,)
# &gt; array([b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;, b&#39;Iris-setosa&#39;,
# &gt;        b&#39;Iris-setosa&#39;],
# &gt;       dtype=&#39;|S18&#39;)
</code></pre><h3 id="如何将1维元组数组转换为2维numpy数组"><a href="#如何将1维元组数组转换为2维numpy数组" class="headerlink" title="如何将1维元组数组转换为2维numpy数组"></a>如何将1维元组数组转换为2维numpy数组</h3><pre><code>通过省略鸢尾属植物数据集种类的文本字段，将一维鸢尾属植物数据集转换为二维数组iris_2d
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_1d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=None)

# Solution:
# Method 1: Convert each row to a list and get the first 4 items
iris_2d = np.array([row.tolist()[:4] for row in iris_1d])
iris_2d[:4]

# Alt Method 2: Import only the first 4 columns from source url
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])
iris_2d[:4]
# &gt; array([[ 5.1,  3.5,  1.4,  0.2],
# &gt;        [ 4.9,  3. ,  1.4,  0.2],
# &gt;        [ 4.7,  3.2,  1.3,  0.2],
# &gt;        [ 4.6,  3.1,  1.5,  0.2]])
</code></pre><h3 id="如何规范化数组，使数组的值正好介于0和1之间"><a href="#如何规范化数组，使数组的值正好介于0和1之间" class="headerlink" title="如何规范化数组，使数组的值正好介于0和1之间"></a>如何规范化数组，使数组的值正好介于0和1之间</h3><pre><code>创建一种标准化形式的鸢尾属植物间隔长度，其值正好介于0和1之间，这样最小值为0，最大值为1
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
sepallength = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0])

# Solution
Smax, Smin = sepallength.max(), sepallength.min()
S = (sepallength - Smin)/(Smax - Smin)
# or 
S = (sepallength - Smin)/sepallength.ptp()  # Thanks, David Ojeda!
print(S)
# &gt; [ 0.222  0.167  0.111  0.083  0.194  0.306  0.083  0.194  0.028  0.167
# &gt;   0.306  0.139  0.139  0.     0.417  0.389  0.306  0.222  0.389  0.222
# &gt;   0.306  0.222  0.083  0.222  0.139  0.194  0.194  0.25   0.25   0.111
# &gt;   0.139  0.306  0.25   0.333  0.167  0.194  0.333  0.167  0.028  0.222
# &gt;   0.194  0.056  0.028  0.194  0.222  0.139  0.222  0.083  0.278  0.194
# &gt;   0.75   0.583  0.722  0.333  0.611  0.389  0.556  0.167  0.639  0.25
# &gt;   0.194  0.444  0.472  0.5    0.361  0.667  0.361  0.417  0.528  0.361
# &gt;   0.444  0.5    0.556  0.5    0.583  0.639  0.694  0.667  0.472  0.389
# &gt;   0.333  0.333  0.417  0.472  0.306  0.472  0.667  0.556  0.361  0.333
# &gt;   0.333  0.5    0.417  0.194  0.361  0.389  0.389  0.528  0.222  0.389
# &gt;   0.556  0.417  0.778  0.556  0.611  0.917  0.167  0.833  0.667  0.806
# &gt;   0.611  0.583  0.694  0.389  0.417  0.583  0.611  0.944  0.944  0.472
# &gt;   0.722  0.361  0.944  0.556  0.667  0.806  0.528  0.5    0.583  0.806
# &gt;   0.861  1.     0.583  0.556  0.5    0.944  0.556  0.583  0.472  0.722
# &gt;   0.667  0.722  0.417  0.694  0.667  0.667  0.556  0.611  0.528  0.444]
</code></pre><h3 id="如何计算Softmax得分"><a href="#如何计算Softmax得分" class="headerlink" title="如何计算Softmax得分"></a>如何计算Softmax得分</h3><pre><code>计算sepallength的softmax分数
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
sepallength = np.array([float(row[0]) for row in iris])

# Solution
def softmax(x):
    &quot;&quot;&quot;Compute softmax values for each sets of scores in x.
    https://stackoverflow.com/questions/34968722/how-to-implement-the-softmax-function-in-python&quot;&quot;&quot;
    e_x = np.exp(x - np.max(x))
    return e_x / e_x.sum(axis=0)

print(softmax(sepallength))
# &gt; [ 0.002  0.002  0.001  0.001  0.002  0.003  0.001  0.002  0.001  0.002
# &gt;   0.003  0.002  0.002  0.001  0.004  0.004  0.003  0.002  0.004  0.002
# &gt;   0.003  0.002  0.001  0.002  0.002  0.002  0.002  0.002  0.002  0.001
# &gt;   0.002  0.003  0.002  0.003  0.002  0.002  0.003  0.002  0.001  0.002
# &gt;   0.002  0.001  0.001  0.002  0.002  0.002  0.002  0.001  0.003  0.002
# &gt;   0.015  0.008  0.013  0.003  0.009  0.004  0.007  0.002  0.01   0.002
# &gt;   0.002  0.005  0.005  0.006  0.004  0.011  0.004  0.004  0.007  0.004
# &gt;   0.005  0.006  0.007  0.006  0.008  0.01   0.012  0.011  0.005  0.004
# &gt;   0.003  0.003  0.004  0.005  0.003  0.005  0.011  0.007  0.004  0.003
# &gt;   0.003  0.006  0.004  0.002  0.004  0.004  0.004  0.007  0.002  0.004
# &gt;   0.007  0.004  0.016  0.007  0.009  0.027  0.002  0.02   0.011  0.018
# &gt;   0.009  0.008  0.012  0.004  0.004  0.008  0.009  0.03   0.03   0.005
# &gt;   0.013  0.004  0.03   0.007  0.011  0.018  0.007  0.006  0.008  0.018
# &gt;   0.022  0.037  0.008  0.007  0.006  0.03   0.007  0.008  0.005  0.013
# &gt;   0.011  0.013  0.004  0.012  0.011  0.011  0.007  0.009  0.007  0.005]
</code></pre><h3 id="如何找到numpy数组的百分位数"><a href="#如何找到numpy数组的百分位数" class="headerlink" title="如何找到numpy数组的百分位数"></a>如何找到numpy数组的百分位数</h3><pre><code>找到鸢尾属植物数据集的第5和第95百分位数
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
sepallength = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0])

# Solution
np.percentile(sepallength, q=[5, 95])
# &gt; array([ 4.6  ,  7.255])
</code></pre><h3 id="如何在数组中的随机位置插入值"><a href="#如何在数组中的随机位置插入值" class="headerlink" title="如何在数组中的随机位置插入值"></a>如何在数组中的随机位置插入值</h3><pre><code>在iris_2d数据集中的20个随机位置插入np.nan值
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Method 1
i, j = np.where(iris_2d)

# i, j contain the row numbers and column numbers of 600 elements of iris_x
np.random.seed(100)
iris_2d[np.random.choice((i), 20), np.random.choice((j), 20)] = np.nan

# Method 2
np.random.seed(100)
iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan

# Print first 10 rows
print(iris_2d[:10])
# &gt; [[b&#39;5.1&#39; b&#39;3.5&#39; b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;3.0&#39; b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.7&#39; b&#39;3.2&#39; b&#39;1.3&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.1&#39; b&#39;1.5&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;5.0&#39; b&#39;3.6&#39; b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;5.4&#39; b&#39;3.9&#39; b&#39;1.7&#39; b&#39;0.4&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.4&#39; b&#39;1.4&#39; b&#39;0.3&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;5.0&#39; b&#39;3.4&#39; b&#39;1.5&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.4&#39; nan b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;3.1&#39; b&#39;1.5&#39; b&#39;0.1&#39; b&#39;Iris-setosa&#39;]]
</code></pre><h3 id="如何在numpy数组中找到缺失值的位置"><a href="#如何在numpy数组中找到缺失值的位置" class="headerlink" title="如何在numpy数组中找到缺失值的位置"></a>如何在numpy数组中找到缺失值的位置</h3><pre><code>在iris_2d的sepallength中查找缺失值的数量和位置（第1列）
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])
iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan

# Solution
print(&quot;Number of missing values: \n&quot;, np.isnan(iris_2d[:, 0]).sum())
print(&quot;Position of missing values: \n&quot;, np.where(np.isnan(iris_2d[:, 0])))
# &gt; Number of missing values: 
# &gt;  5
# &gt; Position of missing values: 
# &gt;  (array([ 39,  88,  99, 130, 147]),)
</code></pre><h3 id="如何根据两个或多个条件过滤numpy数组"><a href="#如何根据两个或多个条件过滤numpy数组" class="headerlink" title="如何根据两个或多个条件过滤numpy数组"></a>如何根据两个或多个条件过滤numpy数组</h3><pre><code>过滤具有petallength（第3列）&gt; 1.5 和 sepallength（第1列）&lt; 5.0 的iris_2d行
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])

# Solution
condition = (iris_2d[:, 2] &gt; 1.5) &amp; (iris_2d[:, 0] &lt; 5.0)
iris_2d[condition]
# &gt; array([[ 4.8,  3.4,  1.6,  0.2],
# &gt;        [ 4.8,  3.4,  1.9,  0.2],
# &gt;        [ 4.7,  3.2,  1.6,  0.2],
# &gt;        [ 4.8,  3.1,  1.6,  0.2],
# &gt;        [ 4.9,  2.4,  3.3,  1. ],
# &gt;        [ 4.9,  2.5,  4.5,  1.7]])
</code></pre><h3 id="如何从numpy数组中删除包含缺失值的行"><a href="#如何从numpy数组中删除包含缺失值的行" class="headerlink" title="如何从numpy数组中删除包含缺失值的行"></a>如何从numpy数组中删除包含缺失值的行</h3><pre><code>选择没有任何nan值的iris_2d行
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])
iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan

# Solution
# No direct numpy function for this.
# Method 1:
any_nan_in_row = np.array([~np.any(np.isnan(row)) for row in iris_2d])
iris_2d[any_nan_in_row][:5]

# Method 2: (By Rong)
iris_2d[np.sum(np.isnan(iris_2d), axis = 1) == 0][:5]
# &gt; array([[ 4.9,  3. ,  1.4,  0.2],
# &gt;        [ 4.7,  3.2,  1.3,  0.2],
# &gt;        [ 4.6,  3.1,  1.5,  0.2],
# &gt;        [ 5. ,  3.6,  1.4,  0.2],
# &gt;        [ 5.4,  3.9,  1.7,  0.4]])
</code></pre><h3 id="如何找到numpy数组的两列之间的相关性"><a href="#如何找到numpy数组的两列之间的相关性" class="headerlink" title="如何找到numpy数组的两列之间的相关性"></a>如何找到numpy数组的两列之间的相关性</h3><pre><code>在iris_2d中找出SepalLength（第1列）和PetalLength（第3列）之间的相关性
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])

# Solution 1
np.corrcoef(iris[:, 0], iris[:, 2])[0, 1]

# Solution 2
from scipy.stats.stats import pearsonr  
corr, p_value = pearsonr(iris[:, 0], iris[:, 2])
print(corr)

# Correlation coef indicates the degree of linear relationship between two numeric variables.
# It can range between -1 to +1.

# The p-value roughly indicates the probability of an uncorrelated system producing 
# datasets that have a correlation at least as extreme as the one computed.
# The lower the p-value (&lt;0.01), stronger is the significance of the relationship.
# It is not an indicator of the strength.
# &gt; 0.871754157305
</code></pre><h3 id="如何查找给定数组是否具有任何空值"><a href="#如何查找给定数组是否具有任何空值" class="headerlink" title="如何查找给定数组是否具有任何空值"></a>如何查找给定数组是否具有任何空值</h3><pre><code>找出iris_2d是否有任何缺失值
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])

np.isnan(iris_2d).any()
# &gt; False
</code></pre><h3 id="如何在numpy数组中用0替换所有缺失值"><a href="#如何在numpy数组中用0替换所有缺失值" class="headerlink" title="如何在numpy数组中用0替换所有缺失值"></a>如何在numpy数组中用0替换所有缺失值</h3><pre><code>在numpy数组中将所有出现的nan替换为0
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;float&#39;, usecols=[0,1,2,3])
iris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan

# Solution
iris_2d[np.isnan(iris_2d)] = 0
iris_2d[:4]
# &gt; array([[ 5.1,  3.5,  1.4,  0. ],
# &gt;        [ 4.9,  3. ,  1.4,  0.2],
# &gt;        [ 4.7,  3.2,  1.3,  0.2],
# &gt;        [ 4.6,  3.1,  1.5,  0.2]])
</code></pre><h3 id="如何在numpy数组中查找唯一值的计数"><a href="#如何在numpy数组中查找唯一值的计数" class="headerlink" title="如何在numpy数组中查找唯一值的计数"></a>如何在numpy数组中查找唯一值的计数</h3><pre><code>找出鸢尾属植物物种中的独特值和独特值的数量
# Import iris keeping the text column intact
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)

# Solution
# Extract the species column as an array
species = np.array([row.tolist()[4] for row in iris])

# Get the unique values and the counts
np.unique(species, return_counts=True)
# &gt; (array([b&#39;Iris-setosa&#39;, b&#39;Iris-versicolor&#39;, b&#39;Iris-virginica&#39;],
# &gt;        dtype=&#39;|S15&#39;), array([50, 50, 50]))
</code></pre><h3 id="如何将数字转换为分类（文本）数组"><a href="#如何将数字转换为分类（文本）数组" class="headerlink" title="如何将数字转换为分类（文本）数组"></a>如何将数字转换为分类（文本）数组</h3><pre><code>将iris_2d的花瓣长度（第3列）加入以形成文本数组，这样如果花瓣长度为
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)

# Bin petallength 
petal_length_bin = np.digitize(iris[:, 2].astype(&#39;float&#39;), [0, 3, 5, 10])

# Map it to respective category
label_map = {1: &#39;small&#39;, 2: &#39;medium&#39;, 3: &#39;large&#39;, 4: np.nan}
petal_length_cat = [label_map[x] for x in petal_length_bin]

# View
petal_length_cat[:4]
&lt;# &gt; [&#39;small&#39;, &#39;small&#39;, &#39;small&#39;, &#39;small&#39;]
</code></pre><h3 id="如何从numpy数组的现有列创建新列"><a href="#如何从numpy数组的现有列创建新列" class="headerlink" title="如何从numpy数组的现有列创建新列"></a>如何从numpy数组的现有列创建新列</h3><pre><code>在iris_2d中为卷创建一个新列，其中volume是（pi x petallength x sepal_length ^ 2）/ 3)
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris_2d = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Solution
# Compute volume
sepallength = iris_2d[:, 0].astype(&#39;float&#39;)
petallength = iris_2d[:, 2].astype(&#39;float&#39;)
volume = (np.pi * petallength * (sepallength**2))/3

# Introduce new dimension to match iris_2d&#39;s
volume = volume[:, np.newaxis]

# Add the new column
out = np.hstack([iris_2d, volume])

# View
out[:4]
# &gt; array([[b&#39;5.1&#39;, b&#39;3.5&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 38.13265162927291],
# &gt;        [b&#39;4.9&#39;, b&#39;3.0&#39;, b&#39;1.4&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 35.200498485922445],
# &gt;        [b&#39;4.7&#39;, b&#39;3.2&#39;, b&#39;1.3&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 30.0723720777127],
# &gt;        [b&#39;4.6&#39;, b&#39;3.1&#39;, b&#39;1.5&#39;, b&#39;0.2&#39;, b&#39;Iris-setosa&#39;, 33.238050274980004]], dtype=object)
</code></pre><h3 id="如何在numpy中进行概率抽样"><a href="#如何在numpy中进行概率抽样" class="headerlink" title="如何在numpy中进行概率抽样"></a>如何在numpy中进行概率抽样</h3><pre><code>随机抽鸢尾属植物的种类，使得刚毛的数量是云芝和维吉尼亚的两倍
# Import iris keeping the text column intact
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Solution
# Get the species column
species = iris[:, 4]

# Approach 1: Generate Probablistically
np.random.seed(100)
a = np.array([&#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;])
species_out = np.random.choice(a, 150, p=[0.5, 0.25, 0.25])

# Approach 2: Probablistic Sampling (preferred)
np.random.seed(100)
probs = np.r_[np.linspace(0, 0.500, num=50), np.linspace(0.501, .750, num=50), np.linspace(.751, 1.0, num=50)]
index = np.searchsorted(probs, np.random.random(150))
species_out = species[index]
print(np.unique(species_out, return_counts=True))

# &gt; (array([b&#39;Iris-setosa&#39;, b&#39;Iris-versicolor&#39;, b&#39;Iris-virginica&#39;], dtype=object), array([77, 37, 36]))
方法2是首选方法，因为它创建了一个索引变量，该变量可用于取样2维表格数据。
</code></pre><h3 id="如何在按另一个数组分组时获取数组的第二大值"><a href="#如何在按另一个数组分组时获取数组的第二大值" class="headerlink" title="如何在按另一个数组分组时获取数组的第二大值"></a>如何在按另一个数组分组时获取数组的第二大值</h3><pre><code>第二长的物种setosa的价值是多少
# Import iris keeping the text column intact
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Solution
# Get the species and petal length columns
petal_len_setosa = iris[iris[:, 4] == b&#39;Iris-setosa&#39;, [2]].astype(&#39;float&#39;)

# Get the second last value
np.unique(np.sort(petal_len_setosa))[-2]
# &gt; 1.7
</code></pre><h3 id="如何按列对2D数组进行排序"><a href="#如何按列对2D数组进行排序" class="headerlink" title="如何按列对2D数组进行排序"></a>如何按列对2D数组进行排序</h3><pre><code>根据sepallength列对虹膜数据集进行排序
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)
# Sort by column position 0: SepalLength
print(iris[iris[:,0].argsort()][:20])
# &gt; [[b&#39;4.3&#39; b&#39;3.0&#39; b&#39;1.1&#39; b&#39;0.1&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.4&#39; b&#39;3.2&#39; b&#39;1.3&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.4&#39; b&#39;3.0&#39; b&#39;1.3&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.4&#39; b&#39;2.9&#39; b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.5&#39; b&#39;2.3&#39; b&#39;1.3&#39; b&#39;0.3&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.6&#39; b&#39;1.0&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.1&#39; b&#39;1.5&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.4&#39; b&#39;1.4&#39; b&#39;0.3&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.6&#39; b&#39;3.2&#39; b&#39;1.4&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.7&#39; b&#39;3.2&#39; b&#39;1.3&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.7&#39; b&#39;3.2&#39; b&#39;1.6&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.8&#39; b&#39;3.0&#39; b&#39;1.4&#39; b&#39;0.1&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.8&#39; b&#39;3.0&#39; b&#39;1.4&#39; b&#39;0.3&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.8&#39; b&#39;3.4&#39; b&#39;1.9&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.8&#39; b&#39;3.4&#39; b&#39;1.6&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.8&#39; b&#39;3.1&#39; b&#39;1.6&#39; b&#39;0.2&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;2.4&#39; b&#39;3.3&#39; b&#39;1.0&#39; b&#39;Iris-versicolor&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;2.5&#39; b&#39;4.5&#39; b&#39;1.7&#39; b&#39;Iris-virginica&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;3.1&#39; b&#39;1.5&#39; b&#39;0.1&#39; b&#39;Iris-setosa&#39;]
# &gt;  [b&#39;4.9&#39; b&#39;3.1&#39; b&#39;1.5&#39; b&#39;0.1&#39; b&#39;Iris-setosa&#39;]]
</code></pre><h3 id="如何在numpy数组中找到最常见的值"><a href="#如何在numpy数组中找到最常见的值" class="headerlink" title="如何在numpy数组中找到最常见的值"></a>如何在numpy数组中找到最常见的值</h3><pre><code>在鸢尾属植物数据集中找到最常见的花瓣长度值（第3列）
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Solution:
vals, counts = np.unique(iris[:, 2], return_counts=True)
print(vals[np.argmax(counts)])
# &gt; b&#39;1.5&#39;
</code></pre><h3 id="如何找到第一次出现的值大于给定值的位置"><a href="#如何找到第一次出现的值大于给定值的位置" class="headerlink" title="如何找到第一次出现的值大于给定值的位置"></a>如何找到第一次出现的值大于给定值的位置</h3><pre><code>在虹膜数据集的petalwidth第4列中查找第一次出现的值大于1.0的位置
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)

# Solution: (edit: changed argmax to argwhere. Thanks Rong!)
np.argwhere(iris[:, 3].astype(float) &gt; 1.0)[0]
# &gt; 50
</code></pre><h3 id="如何将大于给定值的所有值替换为给定的截止值"><a href="#如何将大于给定值的所有值替换为给定的截止值" class="headerlink" title="如何将大于给定值的所有值替换为给定的截止值"></a>如何将大于给定值的所有值替换为给定的截止值</h3><pre><code>从数组a中，替换所有大于30到30和小于10到10的值
# Input
np.set_printoptions(precision=2)
np.random.seed(100)
a = np.random.uniform(1,50, 20)

# Solution 1: Using np.clip
np.clip(a, a_min=10, a_max=30)

# Solution 2: Using np.where
print(np.where(a &lt; 10, 10, np.where(a &gt; 30, 30, a)))
# &gt; [ 27.63  14.64  21.8   30.    10.    10.    30.    30.    10.    29.18  30.
# &gt;   11.25  10.08  10.    11.77  30.    30.    10.    30.    14.43]
</code></pre><h3 id="如何从numpy数组中获取最大n值的位置"><a href="#如何从numpy数组中获取最大n值的位置" class="headerlink" title="如何从numpy数组中获取最大n值的位置"></a>如何从numpy数组中获取最大n值的位置</h3><pre><code>获取给定数组a中前5个最大值的位置
# Input
np.random.seed(100)
a = np.random.uniform(1,50, 20)

# Solution:
print(a.argsort())
# &gt; [18 7 3 10 15]

# Solution 2:
np.argpartition(-a, 5)[:5]
# &gt; [15 10  3  7 18]

# Below methods will get you the values.
# Method 1:
a[a.argsort()][-5:]

# Method 2:
np.sort(a)[-5:]

# Method 3:
np.partition(a, kth=-5)[-5:]

# Method 4:
a[np.argpartition(-a, 5)][:5]
</code></pre><h3 id="如何计算数组中所有可能值的行数"><a href="#如何计算数组中所有可能值的行数" class="headerlink" title="如何计算数组中所有可能值的行数"></a>如何计算数组中所有可能值的行数</h3><pre><code>按行计算唯一值的计数
#给定#
np.random.seed(100)
arr = np.random.randint(1,11,size=(6, 10))
arr
&gt; array([[ 9,  9,  4,  8,  8,  1,  5,  3,  6,  3],
&gt;        [ 3,  3,  2,  1,  9,  5,  1, 10,  7,  3],
&gt;        [ 5,  2,  6,  4,  5,  5,  4,  8,  2,  2],
&gt;        [ 8,  8,  1,  3, 10, 10,  4,  3,  6,  9],
&gt;        [ 2,  1,  8,  7,  3,  1,  9,  3,  6,  2],
&gt;        [ 9,  2,  6,  5,  3,  9,  4,  6,  1, 10]])
#期望输出#
&gt; [[1, 0, 2, 1, 1, 1, 0, 2, 2, 0],
&gt;  [2, 1, 3, 0, 1, 0, 1, 0, 1, 1],
&gt;  [0, 3, 0, 2, 3, 1, 0, 1, 0, 0],
&gt;  [1, 0, 2, 1, 0, 1, 0, 2, 1, 2],
&gt;  [2, 2, 2, 0, 0, 1, 1, 1, 1, 0],
&gt;  [1, 1, 1, 1, 1, 2, 0, 0, 2, 1]]
</code></pre><hr>
<pre><code>输出包含10列，表示从1到10的数字。这些值是各行中数字的计数。
例如，cell(0，2)的值为2，这意味着数字3在第一行中恰好出现了2次。
# **给定：**
np.random.seed(100)
arr = np.random.randint(1,11,size=(6, 10))
arr
# &gt; array([[ 9,  9,  4,  8,  8,  1,  5,  3,  6,  3],
# &gt;        [ 3,  3,  2,  1,  9,  5,  1, 10,  7,  3],
# &gt;        [ 5,  2,  6,  4,  5,  5,  4,  8,  2,  2],
# &gt;        [ 8,  8,  1,  3, 10, 10,  4,  3,  6,  9],
# &gt;        [ 2,  1,  8,  7,  3,  1,  9,  3,  6,  2],
# &gt;        [ 9,  2,  6,  5,  3,  9,  4,  6,  1, 10]])
# Solution
def counts_of_all_values_rowwise(arr2d):
    # Unique values and its counts row wise
    num_counts_array = [np.unique(row, return_counts=True) for row in arr2d]

    # Counts of all values row wise
    return([[int(b[a==i]) if i in a else 0 for i in np.unique(arr2d)] for a, b in num_counts_array])

# Print
print(np.arange(1,11))
counts_of_all_values_rowwise(arr)
# &gt; [ 1  2  3  4  5  6  7  8  9 10]

# &gt; [[1, 0, 2, 1, 1, 1, 0, 2, 2, 0],
# &gt;  [2, 1, 3, 0, 1, 0, 1, 0, 1, 1],
# &gt;  [0, 3, 0, 2, 3, 1, 0, 1, 0, 0],
# &gt;  [1, 0, 2, 1, 0, 1, 0, 2, 1, 2],
# &gt;  [2, 2, 2, 0, 0, 1, 1, 1, 1, 0],
# &gt;  [1, 1, 1, 1, 1, 2, 0, 0, 2, 1]]

# Example 2:
arr = np.array([np.array(list(&#39;bill clinton&#39;)), np.array(list(&#39;narendramodi&#39;)), np.array(list(&#39;jjayalalitha&#39;))])
print(np.unique(arr))
counts_of_all_values_rowwise(arr)
# &gt; [&#39; &#39; &#39;a&#39; &#39;b&#39; &#39;c&#39; &#39;d&#39; &#39;e&#39; &#39;h&#39; &#39;i&#39; &#39;j&#39; &#39;l&#39; &#39;m&#39; &#39;n&#39; &#39;o&#39; &#39;r&#39; &#39;t&#39; &#39;y&#39;]

# &gt; [[1, 0, 1, 1, 0, 0, 0, 2, 0, 3, 0, 2, 1, 0, 1, 0],
# &gt;  [0, 2, 0, 0, 2, 1, 0, 1, 0, 0, 1, 2, 1, 2, 0, 0],
# &gt;  [0, 4, 0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 0, 0, 1, 1]]
</code></pre><h3 id="如何将数组转换为平面一维数组"><a href="#如何将数组转换为平面一维数组" class="headerlink" title="如何将数组转换为平面一维数组"></a>如何将数组转换为平面一维数组</h3><pre><code>将array_of_arrays转换为扁平线性1d数组
# **给定：**
arr1 = np.arange(3)
arr2 = np.arange(3,7)
arr3 = np.arange(7,10)

array_of_arrays = np.array([arr1, arr2, arr3])
print(&#39;array_of_arrays: &#39;, array_of_arrays)

# Solution 1
arr_2d = np.array([a for arr in array_of_arrays for a in arr])

# Solution 2:
arr_2d = np.concatenate(array_of_arrays)
print(arr_2d)
# &gt; array_of_arrays:  [array([0, 1, 2]) array([3, 4, 5, 6]) array([7, 8, 9])]
# &gt; [0 1 2 3 4 5 6 7 8 9] 
</code></pre><h3 id="如何在numpy中为数组生成单热编码"><a href="#如何在numpy中为数组生成单热编码" class="headerlink" title="如何在numpy中为数组生成单热编码"></a>如何在numpy中为数组生成单热编码</h3><pre><code>计算一次性编码(数组中每个唯一值的虚拟二进制变量)
# **给定：**
np.random.seed(101) 
arr = np.random.randint(1,4, size=6)
arr
# &gt; array([2, 3, 2, 2, 2, 1])

# Solution:
def one_hot_encodings(arr):
    uniqs = np.unique(arr)
    out = np.zeros((arr.shape[0], uniqs.shape[0]))
    for i, k in enumerate(arr):
        out[i, k-1] = 1
    return out

one_hot_encodings(arr)
# &gt; array([[ 0.,  1.,  0.],
# &gt;        [ 0.,  0.,  1.],
# &gt;        [ 0.,  1.,  0.],
# &gt;        [ 0.,  1.,  0.],
# &gt;        [ 0.,  1.,  0.],
# &gt;        [ 1.,  0.,  0.]])

# Method 2:
(arr[:, None] == np.unique(arr)).view(np.int8)
</code></pre><h3 id="如何创建按分类变量分组的行号"><a href="#如何创建按分类变量分组的行号" class="headerlink" title="如何创建按分类变量分组的行号"></a>如何创建按分类变量分组的行号</h3><pre><code>创建按分类变量分组的行号。使用以下来自鸢尾属植物物种的样本作为输入
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
species = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;str&#39;, usecols=4)
np.random.seed(100)
species_small = np.sort(np.random.choice(species, size=20))
species_small
# &gt; array([&#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;,
# &gt;        &#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;,
# &gt;        &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;,
# &gt;        &#39;Iris-virginica&#39;],
# &gt;       dtype=&#39;&lt;U15&#39;)
print([i for val in np.unique(species_small) for i, grp in enumerate(species_small[species_small==val])])
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5]
</code></pre><h3 id="如何根据给定的分类变量创建组ID"><a href="#如何根据给定的分类变量创建组ID" class="headerlink" title="如何根据给定的分类变量创建组ID"></a>如何根据给定的分类变量创建组ID</h3><pre><code>根据给定的分类变量创建组ID。使用以下来自鸢尾属植物物种的样本作为输入
# **给定：**
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
species = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;str&#39;, usecols=4)
np.random.seed(100)
species_small = np.sort(np.random.choice(species, size=20))
species_small
# &gt; array([&#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;, &#39;Iris-setosa&#39;,
# &gt;        &#39;Iris-setosa&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;, &#39;Iris-versicolor&#39;,
# &gt;        &#39;Iris-versicolor&#39;, &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;,
# &gt;        &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;, &#39;Iris-virginica&#39;,
# &gt;        &#39;Iris-virginica&#39;],
# &gt;       dtype=&#39;&lt;U15&#39;)
# Solution:
output = [np.argwhere(np.unique(species_small) == s).tolist()[0][0] for val in np.unique(species_small) for s in species_small[species_small==val]]

# Solution: For Loop version
output = []
uniqs = np.unique(species_small)

for val in uniqs:  # uniq values in group
    for s in species_small[species_small==val]:  # each element in group
        groupid = np.argwhere(uniqs == s).tolist()[0][0]  # groupid
        output.append(groupid)

print(output)
# &gt; [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]
</code></pre><h3 id="如何使用numpy对数组中的项进行排名"><a href="#如何使用numpy对数组中的项进行排名" class="headerlink" title="如何使用numpy对数组中的项进行排名"></a>如何使用numpy对数组中的项进行排名</h3><pre><code>为给定的数字数组a创建排名
np.random.seed(10)
a = np.random.randint(20, size=10)
print(&#39;Array: &#39;, a)

# Solution
print(a.argsort().argsort())
print(&#39;Array: &#39;, a)
# &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]
# &gt; [4 2 6 0 8 7 9 3 5 1]
# &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]
</code></pre><h3 id="如何使用numpy对多维数组中的项进行排名"><a href="#如何使用numpy对多维数组中的项进行排名" class="headerlink" title="如何使用numpy对多维数组中的项进行排名"></a>如何使用numpy对多维数组中的项进行排名</h3><pre><code>创建与给定数字数组a相同形状的排名数组
# **给定：**
np.random.seed(10)
a = np.random.randint(20, size=[2,5])
print(a)

# Solution
print(a.ravel().argsort().argsort().reshape(a.shape))
# &gt; [[ 9  4 15  0 17]
# &gt;  [16 17  8  9  0]]
# &gt; [[4 2 6 0 8]
# &gt;  [7 9 3 5 1]]
</code></pre><h3 id="如何在二维numpy数组的每一行中找到最大值"><a href="#如何在二维numpy数组的每一行中找到最大值" class="headerlink" title="如何在二维numpy数组的每一行中找到最大值"></a>如何在二维numpy数组的每一行中找到最大值</h3><pre><code>计算给定数组中每行的最大值
# Input
np.random.seed(100)
a = np.random.randint(1,10, [5,3])
a

# Solution 1
np.amax(a, axis=1)

# Solution 2
np.apply_along_axis(np.max, arr=a, axis=1)
# &gt; array([9, 8, 6, 3, 9])
</code></pre><h3 id="如何计算二维numpy数组每行的最小值"><a href="#如何计算二维numpy数组每行的最小值" class="headerlink" title="如何计算二维numpy数组每行的最小值"></a>如何计算二维numpy数组每行的最小值</h3><pre><code>为给定的二维numpy数组计算每行的最小值
# Input
np.random.seed(100)
a = np.random.randint(1,10, [5,3])
a

# Solution
np.apply_along_axis(lambda x: np.min(x)/np.max(x), arr=a, axis=1)
# &gt; array([ 0.44444444,  0.125     ,  0.5       ,  1.        ,  0.11111111])
</code></pre><h3 id="如何在numpy数组中找到重复的记录"><a href="#如何在numpy数组中找到重复的记录" class="headerlink" title="如何在numpy数组中找到重复的记录"></a>如何在numpy数组中找到重复的记录</h3><pre><code>在给定的numpy数组中找到重复的条目(第二次出现以后)，并将它们标记为True。第一次出现应该是False的。
# Input
np.random.seed(100)
a = np.random.randint(0, 5, 10)

## Solution
# There is no direct function to do this as of 1.13.3

# Create an all True array
out = np.full(a.shape[0], True)

# Find the index positions of unique elements
unique_positions = np.unique(a, return_index=True)[1]

# Mark those positions as False
out[unique_positions] = False

print(out)
# &gt; [False  True False  True False False  True  True  True  True]
</code></pre><h3 id="如何找出数字的分组均值"><a href="#如何找出数字的分组均值" class="headerlink" title="如何找出数字的分组均值"></a>如何找出数字的分组均值</h3><pre><code>在二维数字数组中查找按分类列分组的数值列的平均值
# Input
url = &#39;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#39;
iris = np.genfromtxt(url, delimiter=&#39;,&#39;, dtype=&#39;object&#39;)
names = (&#39;sepallength&#39;, &#39;sepalwidth&#39;, &#39;petallength&#39;, &#39;petalwidth&#39;, &#39;species&#39;)


# Solution
# No direct way to implement this. Just a version of a workaround.
numeric_column = iris[:, 1].astype(&#39;float&#39;)  # sepalwidth
grouping_column = iris[:, 4]  # species

# List comprehension version
[[group_val, numeric_column[grouping_column==group_val].mean()] for group_val in np.unique(grouping_column)]

# For Loop version
output = []
for group_val in np.unique(grouping_column):
    output.append([group_val, numeric_column[grouping_column==group_val].mean()])

output
# &gt; [[b&#39;Iris-setosa&#39;, 3.418],
# &gt;  [b&#39;Iris-versicolor&#39;, 2.770],
# &gt;  [b&#39;Iris-virginica&#39;, 2.974]]
</code></pre><h3 id="如何将PIL图像转换为numpy数组"><a href="#如何将PIL图像转换为numpy数组" class="headerlink" title="如何将PIL图像转换为numpy数组"></a>如何将PIL图像转换为numpy数组</h3><pre><code>from io import BytesIO
from PIL import Image
import PIL, requests

# Import image from URL
URL = &#39;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#39;
response = requests.get(URL)

# Read it as Image
I = Image.open(BytesIO(response.content))

# Optionally resize
I = I.resize([150,150])

# Convert to numpy array
arr = np.asarray(I)

# Optionaly Convert it back to an image and show
im = PIL.Image.fromarray(np.uint8(arr))
Image.Image.show(im)
</code></pre><h3 id="如何删除numpy数组中所有缺少的值"><a href="#如何删除numpy数组中所有缺少的值" class="headerlink" title="如何删除numpy数组中所有缺少的值"></a>如何删除numpy数组中所有缺少的值</h3><pre><code>从一维numpy数组中删除所有NaN值
a = np.array([1,2,3,np.nan,5,6,7,np.nan])
a[~np.isnan(a)]
# &gt; array([ 1.,  2.,  3.,  5.,  6.,  7.])
</code></pre><h3 id="如何计算两个数组之间的欧氏距离"><a href="#如何计算两个数组之间的欧氏距离" class="headerlink" title="如何计算两个数组之间的欧氏距离"></a>如何计算两个数组之间的欧氏距离</h3><pre><code>计算两个数组a和数组b之间的欧氏距离
# Input
a = np.array([1,2,3,4,5])
b = np.array([4,5,6,7,8])

# Solution
dist = np.linalg.norm(a-b)
dist
# &gt; 6.7082039324993694
</code></pre><h3 id="如何在一维数组中找到所有的局部极大值-或峰值"><a href="#如何在一维数组中找到所有的局部极大值-或峰值" class="headerlink" title="如何在一维数组中找到所有的局部极大值(或峰值)"></a>如何在一维数组中找到所有的局部极大值(或峰值)</h3><pre><code>找到一个一维数字数组a中的所有峰值。峰顶是两边被较小数值包围的点
a = np.array([1, 3, 7, 1, 2, 6, 0, 1])
doublediff = np.diff(np.sign(np.diff(a)))
peak_locations = np.where(doublediff == -2)[0] + 1
peak_locations
# &gt; array([2, 5])
# 其中，2和5是峰值7和6的位置。
</code></pre><h3 id="如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去"><a href="#如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去" class="headerlink" title="如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去"></a>如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去</h3><pre><code>从2d数组a_2d中减去一维数组b_1D，使得b_1D的每一项从a_2d的相应行中减去
# Input
a_2d = np.array([[3,3,3],[4,4,4],[5,5,5]])
b_1d = np.array([1,2,3])

# Solution
print(a_2d - b_1d[:,None])
# &gt; [[2 2 2]
# &gt;  [2 2 2]
# &gt;  [2 2 2]]
</code></pre><h3 id="如何查找数组中项的第n次重复索引"><a href="#如何查找数组中项的第n次重复索引" class="headerlink" title="如何查找数组中项的第n次重复索引"></a>如何查找数组中项的第n次重复索引</h3><pre><code>找出x中数字1的第5次重复的索引
x = np.array([1, 2, 1, 1, 3, 4, 3, 1, 1, 2, 1, 1, 2])
n = 5

# Solution 1: List comprehension
[i for i, v in enumerate(x) if v == 1][n-1]

# Solution 2: Numpy version
np.where(x == 1)[0][n-1]
# &gt; 8
</code></pre><h3 id="如何将numpy的datetime-64对象转换为datetime的datetime对象"><a href="#如何将numpy的datetime-64对象转换为datetime的datetime对象" class="headerlink" title="如何将numpy的datetime 64对象转换为datetime的datetime对象"></a>如何将numpy的datetime 64对象转换为datetime的datetime对象</h3><pre><code># **给定：** a numpy datetime64 object
dt64 = np.datetime64(&#39;2018-02-25 22:10:10&#39;)

# Solution
from datetime import datetime
dt64.tolist()

# or

dt64.astype(datetime)
# &gt; datetime.datetime(2018, 2, 25, 22, 10, 10)
</code></pre><h3 id="如何计算numpy数组的移动平均值"><a href="#如何计算numpy数组的移动平均值" class="headerlink" title="如何计算numpy数组的移动平均值"></a>如何计算numpy数组的移动平均值</h3><pre><code>对于给定的一维数组，计算窗口大小为3的移动平均值
# Solution
# Source: https://stackoverflow.com/questions/14313510/how-to-calculate-moving-average-using-numpy
def moving_average(a, n=3) :
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n

np.random.seed(100)
Z = np.random.randint(10, size=10)
print(&#39;array: &#39;, Z)
# Method 1
moving_average(Z, n=3).round(2)

# Method 2:  # Thanks AlanLRH!
# np.ones(3)/3 gives equal weights. Use np.ones(4)/4 for window size 4.
np.convolve(Z, np.ones(3)/3, mode=&#39;valid&#39;) . 


# &gt; array:  [8 8 3 7 7 0 4 2 5 2]
# &gt; moving average:  [ 6.33  6.    5.67  4.67  3.67  2.    3.67  3.  ]
</code></pre><h3 id="如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列"><a href="#如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列" class="headerlink" title="如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列"></a>如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列</h3><pre><code>创建长度为10的numpy数组，从5开始，在连续的数字之间的步长为3
length = 10
start = 5
step = 3

def seq(start, length, step):
    end = start + (step*length)
    return np.arange(start, end, step)

seq(start, length, step)
# &gt; array([ 5,  8, 11, 14, 17, 20, 23, 26, 29, 32])
</code></pre><h3 id="如何填写不规则系列的numpy日期中的缺失日期"><a href="#如何填写不规则系列的numpy日期中的缺失日期" class="headerlink" title="如何填写不规则系列的numpy日期中的缺失日期"></a>如何填写不规则系列的numpy日期中的缺失日期</h3><pre><code>给定一系列不连续的日期序列。填写缺失的日期，使其成为连续的日期序列
# Input
dates = np.arange(np.datetime64(&#39;2018-02-01&#39;), np.datetime64(&#39;2018-02-25&#39;), 2)
print(dates)

# Solution ---------------
filled_in = np.array([np.arange(date, (date+d)) for date, d in zip(dates, np.diff(dates))]).reshape(-1)

# add the last day
output = np.hstack([filled_in, dates[-1]])
output

# For loop version -------
out = []
for date, d in zip(dates, np.diff(dates)):
    out.append(np.arange(date, (date+d)))

filled_in = np.array(out).reshape(-1)

# add the last day
output = np.hstack([filled_in, dates[-1]])
output
# &gt; [&#39;2018-02-01&#39; &#39;2018-02-03&#39; &#39;2018-02-05&#39; &#39;2018-02-07&#39; &#39;2018-02-09&#39;
# &gt;  &#39;2018-02-11&#39; &#39;2018-02-13&#39; &#39;2018-02-15&#39; &#39;2018-02-17&#39; &#39;2018-02-19&#39;
# &gt;  &#39;2018-02-21&#39; &#39;2018-02-23&#39;]

# &gt; array([&#39;2018-02-01&#39;, &#39;2018-02-02&#39;, &#39;2018-02-03&#39;, &#39;2018-02-04&#39;,
# &gt;        &#39;2018-02-05&#39;, &#39;2018-02-06&#39;, &#39;2018-02-07&#39;, &#39;2018-02-08&#39;,
# &gt;        &#39;2018-02-09&#39;, &#39;2018-02-10&#39;, &#39;2018-02-11&#39;, &#39;2018-02-12&#39;,
# &gt;        &#39;2018-02-13&#39;, &#39;2018-02-14&#39;, &#39;2018-02-15&#39;, &#39;2018-02-16&#39;,
# &gt;        &#39;2018-02-17&#39;, &#39;2018-02-18&#39;, &#39;2018-02-19&#39;, &#39;2018-02-20&#39;,
# &gt;        &#39;2018-02-21&#39;, &#39;2018-02-22&#39;, &#39;2018-02-23&#39;], dtype=&#39;datetime64[D]&#39;)
</code></pre><h3 id="如何从给定的一维数组创建步长"><a href="#如何从给定的一维数组创建步长" class="headerlink" title="如何从给定的一维数组创建步长"></a>如何从给定的一维数组创建步长</h3><pre><code>从给定的一维数组arr中，利用步进生成一个二维矩阵，窗口长度为4，步距为2，类似于 [[0,1,2,3], [2,3,4,5], [4,5,6,7]..]
#给定#
arr = np.arange(15) 
arr
# &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
#期望输出#
# &gt; [[ 0  1  2  3]
# &gt;  [ 2  3  4  5]
# &gt;  [ 4  5  6  7]
# &gt;  [ 6  7  8  9]
# &gt;  [ 8  9 10 11]
# &gt;  [10 11 12 13]]
#答案#
def gen_strides(a, stride_len=5, window_len=5):
    n_strides = ((a.size-window_len)//stride_len) + 1
# return np.array([a[s:(s+window_len)] for s in np.arange(0, a.size, stride_len)[:n_strides]])
    return np.array([a[s:(s+window_len)] for s in np.arange(0, n_strides*stride_len, stride_len)])

print(gen_strides(np.arange(15), stride_len=2, window_len=4))
# &gt; [[ 0  1  2  3]
# &gt;  [ 2  3  4  5]
# &gt;  [ 4  5  6  7]
# &gt;  [ 6  7  8  9]
# &gt;  [ 8  9 10 11]
# &gt;  [10 11 12 13]]
</code></pre><h3 id="如何计算闵氏距离"><a href="#如何计算闵氏距离" class="headerlink" title="如何计算闵氏距离"></a>如何计算闵氏距离</h3><p><img src="https://i.imgur.com/Q9IrylQ.png" alt></p>
<p><strong>其中p是一个变参数。</strong></p>
<p><strong>当p=1时，就是曼哈顿距离</strong></p>
<p><strong>当p=2时，就是欧氏距离</strong></p>
<p><strong>当p→∞时，就是切比雪夫距离</strong></p>
<p><em>根据变参数的不同，闵氏距离可以表示一类的距离</em></p>
<pre><code>np.linalg.norm
</code></pre><h3 id="如何计算欧式距离"><a href="#如何计算欧式距离" class="headerlink" title="如何计算欧式距离"></a>如何计算欧式距离</h3><p><img src="https://i.imgur.com/SdiuSTB.png" alt></p>
<pre><code>a = np.random.randint(0,5,5)
b = np.random.randint(5,10,5)
# Method1
result1 = np.sqrt(np.sum(np.square(a-b)))
# Method2
result2 = np.linalg.norm(a - b)
</code></pre><h3 id="如何计算曼哈顿距离"><a href="#如何计算曼哈顿距离" class="headerlink" title="如何计算曼哈顿距离"></a>如何计算曼哈顿距离</h3><p><img src="https://i.imgur.com/mmYEuuy.png" alt></p>
<pre><code>#Method1
op3=np.sum(np.abs(a - b))
#Method2
op4=np.linalg.norm(a - b,ord=1)
</code></pre><h3 id="如何计算切比雪夫距离"><a href="#如何计算切比雪夫距离" class="headerlink" title="如何计算切比雪夫距离"></a>如何计算切比雪夫距离</h3><p>国际象棋玩过么？国王走一步能够移动到相邻的8个方格中的任意一个（如图1.11）。那么国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？自己走走试试。你会发现最少步数总是max(| x2-x1| , |y2-y1| ) 步。有一种类似的一种距离度量方法叫切比雪夫距离(L∞范数)。<br><img src="https://i.imgur.com/qJCbmL5.png" alt></p>
<pre><code># Method1
op5=np.abs(a - b).max()
# Method2
op6=np.linalg.norm(a - b,ord=np.inf)
</code></pre><h3 id="如何计算夹角余弦"><a href="#如何计算夹角余弦" class="headerlink" title="如何计算夹角余弦"></a>如何计算夹角余弦</h3><p><img src="https://i.imgur.com/6lUx8H9.png" alt></p>
<p><strong>在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：</strong></p>
<p><img src="https://i.imgur.com/DkDQPZR.png" alt></p>
<p><strong>两个n维样本点A (x11,x12,…,x1n)与 B(x21,x22,…,x2n)的夹角余弦<br>类似的，对于两个n维样本点A(x11,x12,…,x1n)与 B(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度。</strong></p>
<p><img src="https://i.imgur.com/mRIFKzX.png" alt></p>
<p><em>夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。</em></p>
<pre><code>op7=np.dot(a,b)/(np.linalg.norm(a)*(np.linalg.norm(b)))
</code></pre><h2 id="———————————————————————"><a href="#———————————————————————" class="headerlink" title="———————————————————————-"></a>———————————————————————-</h2><h2 id="相关数据集"><a href="#相关数据集" class="headerlink" title="相关数据集"></a>相关数据集</h2><blockquote>
<p><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/machine-learning-databases/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/PySpark搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/PySpark搭建/" itemprop="url">PySpark搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>操作系统：Ubuntu 19,64位。（Server版）</p>
<p>所需软件： Java 8 +，Python 3.5 +, Scala 2.11.12+</p>
<p>安装步骤:</p>
<h4 id="Step-1-Java8安装"><a href="#Step-1-Java8安装" class="headerlink" title="Step 1:Java8安装"></a>Step 1:Java8安装</h4><pre><code>sudo apt-get update
sudo apt-get install openjdk-8-jdk
java -version
</code></pre><h4 id="Step-2-如果Java安装完成后，我们安装Scala"><a href="#Step-2-如果Java安装完成后，我们安装Scala" class="headerlink" title="Step 2: 如果Java安装完成后，我们安装Scala"></a>Step 2: 如果Java安装完成后，我们安装Scala</h4><pre><code>wget https://downloads.lightbend.com/scala/2.12.8/scala-2.12.8.deb
sudo dpkg -i scala-2.12.8.deb
scala -version
</code></pre><h4 id="Step-3-安装-py4j"><a href="#Step-3-安装-py4j" class="headerlink" title="Step 3: 安装 py4j"></a>Step 3: 安装 py4j</h4><p>Py4J在驱动程序上用于Python和Java SparkContext对象之间的本地通信;大型数据传输是通过不同的机制执行的。</p>
<pre><code>sudo pip install py4j
</code></pre><h4 id="Step-4-安装-Spark"><a href="#Step-4-安装-Spark" class="headerlink" title="Step 4: 安装 Spark"></a>Step 4: 安装 Spark</h4><p>到目前为止，我们已经安装了安装Apache Spark所需的依赖项。接下来，我们需要下载并提取spark-2.4.0-bin-hadoop2.7.tgz 。</p>
<pre><code>wget http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz 
tar xvf  spark-2.4.0-bin-hadoop2.7.tgz
</code></pre><p>在通过编辑bashrc文件将其添加到路径中:</p>
<pre><code>vim ~/.bashrc
</code></pre><p>在bashrc文件中添加环境变量（具体SPARK_HOME路径自己设定）</p>
<pre><code>export SPARK_HOME=/home/ubuntu/spark-2.4.0-bin-hadoop2.7
export PATH=${SPARK_HOME}/bin:$PATH
</code></pre><p>最后激活环境变量</p>
<pre><code>source ~/.bashrc
</code></pre><h4 id="Step-5-到目前为止，我们的spark基本安装成功，下面我们来启动pyspark"><a href="#Step-5-到目前为止，我们的spark基本安装成功，下面我们来启动pyspark" class="headerlink" title="Step 5: 到目前为止，我们的spark基本安装成功，下面我们来启动pyspark"></a>Step 5: 到目前为止，我们的spark基本安装成功，下面我们来启动pyspark</h4><p>启动pyspark的命令如下：</p>
<pre><code>pyspark
</code></pre><p>退出命令如下：</p>
<pre><code>exit()
</code></pre><h4 id="Step-6-另外，安装完成后，我们可以通过输入来检查Spark是否正常运行。"><a href="#Step-6-另外，安装完成后，我们可以通过输入来检查Spark是否正常运行。" class="headerlink" title="Step 6: 另外，安装完成后，我们可以通过输入来检查Spark是否正常运行。"></a>Step 6: 另外，安装完成后，我们可以通过输入来检查Spark是否正常运行。</h4><pre><code>./bin/run-example SparkPi 10
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/Tensorflow2.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/Tensorflow2.0/" itemprop="url">Tensorflow2.0-keras</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优化函数"><a href="#优化函数" class="headerlink" title="优化函数"></a>优化函数</h2><p>SGD（随机梯度下降优化器）</p>
<p>RMSprop(训练循环神经网络RNN常用的优化器)</p>
<p>Adam优化器</p>
<h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2><p>合适的学习速率，损失函数随时间下降，直到一个底部不合适的学习速率；<br>不合适的学习速率，损失函数可能会发生震荡。</p>
<h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/Tensorflow2.0入门教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/Tensorflow2.0入门教程/" itemprop="url">Tensorflow2.0教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TensorFlow 2.0默认采用eager执行模式，而且重整了很多混乱的模块。毫无疑问，2.0版本将会逐渐替换1.0版本，所以很有必要趁早入手TensorFlow 2.0。这篇文章将简明扼要地介绍TensorFlow 2.0，以求快速入门。</p>
<h2 id="Eager执行"><a href="#Eager执行" class="headerlink" title="Eager执行"></a>Eager执行</h2><p>TensorFlow的Eager执行时一种命令式编程（imperative programming），这和原生Python是一致的，当你执行某个操作时是立即返回结果的。而TensorFlow一直是采用Graph模式，即先构建一个计算图，然后需要开启Session，喂进实际的数据才真正执行得到结果。显然，eager执行更简洁，我们可以更容易debug自己的代码，这也是为什么PyTorch更简单好用的原因。一个简单的例子如下：</p>
<pre><code>x = tf.ones((2, 2), dtype=tf.dtypes.float32)
y = tf.constant([[1, 2],
                 [3, 4]], dtype=tf.dtypes.float32)
z = tf.matmul(x, y)
print(z)
# tf.Tensor(
# [[4. 6.]
#  [4. 6.]], shape=(2, 2), dtype=float32)

print(z.numpy())
# [[4. 6.]
# [4. 6.]]
</code></pre><p>可以看到在eager执行下，每个操作后的返回值是tf.Tensor，其包含具体值，不再像Graph模式下那样只是一个计算图节点的符号句柄。由于可以立即看到结果，这非常有助于程序debug。更进一步地，调用tf.Tensor.numpy()方法可以获得Tensor所对应的numpy数组。</p>
<p>这种eager执行的另外一个好处是可以使用Python原生功能，比如下面的条件判断：</p>
<pre><code>random_value = tf.random.uniform([], 0, 1)
x = tf.reshape(tf.range(0, 4), [2, 2])
print(random_value)
if random_value.numpy() &gt; 0.5:
    y = tf.matmul(x, x)
else:
    y = tf.add(x, x)
</code></pre><p>这种动态控制流主要得益于eager执行得到Tensor可以取出numpy值，这避免了使用Graph模式下的tf.cond和tf.while等算子。</p>
<p>另外一个重要的问题，在egaer模式下如何计算梯度。在Graph模式时，我们在构建模型前向图时，同时也会构建梯度图，这样实际喂数据执行时可以很方便计算梯度。但是eager执行是动态的，这就需要每一次执行都要记录这些操作以计算梯度，这是通过tf.GradientTape来追踪所执行的操作以计算梯度，下面是一个计算实例：</p>
<pre><code>w = tf.Variable([[1.0]])
with tf.GradientTape() as tape:
  loss = w * w + 2. * w + 5.

grad = tape.gradient(loss, w)
print(grad)  # =&gt; tf.Tensor([[ 4.]], shape=(1, 1), dtype=float32)
</code></pre><h2 id="tf-function"><a href="#tf-function" class="headerlink" title="@tf.function"></a>@tf.function</h2><h3 id="会话执行"><a href="#会话执行" class="headerlink" title="会话执行"></a>会话执行</h3><p>对tf1.X有经验的读者应该不会对让我们又爱又恨的计算图(tf.Graph)和执行会话(tf.Session)感到陌生, 一个常规的流程如下:</p>
<ol>
<li>初始化一个计算图并且将该计算图设置为当前scope下的默认计算图</li>
<li>用TF API设计计算图(比如: y=tf.matmul(a, x) + b)</li>
<li>提前界定好参数共享并划分相应的参数scope</li>
<li>创建并配置好tf.Session</li>
<li>将计算图传给tf.Session</li>
<li>初始化参数</li>
<li>用tf.Session.run来执行计算图的节点, 被执行的节点会反向追踪所有依赖的需要执行的节点并执行计算.</li>
</ol>
<p>以下是上述过程的一个代码例子:</p>
<pre><code>g = tf.Graph() #初始化计算图
with g.as_default(): # 设置为默认计算图
    a = tf.constant([[10,10],[11.,1.]]) 
    x = tf.constant([[1.,0.],[0.,1.]])
    b = tf.Variable(12.)
    y = tf.matmul(a, x) + b # 描述计算图
    init_op = tf.global_variables_initializer() # 待执行节点

with tf.Session() as sess: # 配置会话
    sess.run(init_op) # 执行节点
    print(sess.run(y)) # 输出结果
</code></pre><p>在TF 2.0中, 由于默认为动态图, 计算会直接被执行, 也就是说, 我们不需要</p>
<ul>
<li>定义计算图</li>
<li>会话执行</li>
<li>参数初始化</li>
<li>用scope定义参数分享</li>
<li>用tf.control_dependencies来声明节点的非直接依赖</li>
</ul>
<p>我们可以像写普通python代码(or pytorch)一样, 写了就执行:</p>
<pre><code>a = tf.constant([[10,10],[11.,1.]])
x = tf.constant([[1.,0.],[0.,1.]])
b = tf.Variable(12.)
y = tf.matmul(a, x) + b
print(y.numpy())
</code></pre><p>一般来说, eager代码会比执行相同操作的静态图代码的效率低, 因为很多计算图优化的方法只能用在数据流图上.</p>
<p>如果想在TF 2.0上构建传统的计算图, 我们就需要用到tf.function.</p>
<h3 id="函数-而非会话"><a href="#函数-而非会话" class="headerlink" title="函数, 而非会话"></a>函数, 而非会话</h3><p>TF 2.0的其中一个重要改变就是去除tf.Session(此处应有掌声). 这个改变会迫使用户用更好的方式来组织代码: 不用再用让人纠结的tf.Session来执行代码, 就是一个个python函数, 加上一个简单的装饰器.</p>
<p>在TF 2.0里面, 如果需要构建计算图, 我们只需要给python函数加上@tf.function的装饰器.</p>
<p>这个自动将python代码转成图表示代码的工具就叫做AutoGraph.</p>
<p>在TF 2.0中, 如果一个函数被@tf.function装饰了, 那么AutoGraph将会被自动调用, 从而将python函数转换成可执行的图表示.</p>
<h3 id="tf-function-究竟发生了什么"><a href="#tf-function-究竟发生了什么" class="headerlink" title="tf.function: 究竟发生了什么?"></a>tf.function: 究竟发生了什么?</h3><p>在第一次调用被@tf.function装饰的函数时, 下列事情将会发生:</p>
<ul>
<li>该函数被执行并跟踪。和Tensorflow 1.x类似, Eager会在这个函数中被禁用，因此每个tf.API只会定义一个生成tf.Tensor输出的节点</li>
<li>AutoGraph用于检测可以转换为等效图表示的Python操作（while→tf.while，for→tf.while，if→tf.cond，assert→tf.assert…)</li>
<li>为了保留执行顺序，在每个语句之后自动添加tf.control_dependencies，以便在执行第i+1行时确保第i行已经被执行. 至此计算图已经确定</li>
<li>根据函数名称和输入参数，创建唯一ID并将其与定义好的计算图相关联。计算图被缓存到一个映射表中：map [id] = graph</li>
<li>如果ID配对上了，之后的函数调用都会直接使用该计算图</li>
</ul>
<h3 id="改写到eager-execution"><a href="#改写到eager-execution" class="headerlink" title="改写到eager execution"></a>改写到eager execution</h3><p>要使用tf.function, 第一步需要先将TF 1.X的设计计算图的代码放进python函数里面.</p>
<pre><code>def f():
    a = tf.constant([[10,10],[11.,1.]])
    x = tf.constant([[1.,0.],[0.,1.]])
    b = tf.Variable(12.)
    y = tf.matmul(a, x) + b
    return y
</code></pre><p>应为TF 2.0默认是eager的, 我们可以直接执行该函数(不需要tf.Session):</p>
<pre><code>print(f().numpy())
</code></pre><p>我们就会得到输出:</p>
<pre><code>[[22. 22.]
 [23. 13.]]
</code></pre><h3 id="从eager到tf-function"><a href="#从eager到tf-function" class="headerlink" title="从eager到tf.function"></a>从eager到tf.function</h3><p>我们可以直接用@tf.function来装饰函数f, 我们在原来f的基础上加上宇宙第一的debug大法: print来更好地看看究竟发生了什么.</p>
<pre><code>@tf.function
def f():
    a = tf.constant([[10,10],[11.,1.]])
    x = tf.constant([[1.,0.],[0.,1.]])
    b = tf.Variable(12.)
    y = tf.matmul(a, x) + b
    print(&quot;PRINT: &quot;, y)
    tf.print(&quot;TF-PRINT: &quot;, y)
    return y

f()
</code></pre><p>所以发生了什么呢?</p>
<ul>
<li>@tf.function将函数f包进了tensorflow.python.eager.def_function.Function这个对象, 函数f被赋予到了这个对象的.python_function属性.</li>
<li><p>当f()被执行的时候, 计算图会同时被构建, 但是计算不会执行, 因此我们会得到以下结果, tf.的操作不会被执行:</p>
<p>  PRINT: Tensor(“add:0”, shape=(2, 2), dtype=float32)</p>
</li>
<li><p>最终, 你会看到代码会执行失败:</p>
<p>  ValueError: tf.function-decorated function tried to create variables on non-first call.</p>
</li>
</ul>
<p>在 RFC: Functions, not Session里面有个非常明确的指示:</p>
<blockquote>
<p>State (like tf.Variable objects) are only created the first time the function f is called. 状态(比如tf.Variable) 只会在函数被第一次调用时创建.</p>
</blockquote>
<p>但是 Alexandre Passos指出, 在函数转换成图表示时, 我们没有办法确定tf.function调用了多少次函数, 因此我们在第一次调用函数f时, 在图构建的过程中, 可能会被执行了多次, 这就导致了上述错误.</p>
<p>造成这个错误的根源在于同样的命令在动态图和静态图中的不一致性. 在动态图中, tf.Variable时一个普通的python变量, 超出了其作用域范围就会被销毁. 而在静态图中, tf.Variable则是计算图中一个持续存在的节点, 不受python的作用域的影响. 因此, 这是使用tf.function的第一个教训:</p>
<blockquote>
<p>将一个在动态图中可行的函数转换成静态图需要用静态图的方式思考该函数是否可行</p>
</blockquote>
<p>那么我们可以怎样去规避这个错误呢?</p>
<ol>
<li>将tf.Variable作为函数的参数传入</li>
<li>将父作用域继承tf.Variable</li>
<li>将tf.Variable作为类属性来调用</li>
</ol>
<h3 id="用改变变量作用域来处理"><a href="#用改变变量作用域来处理" class="headerlink" title="用改变变量作用域来处理"></a>用改变变量作用域来处理</h3><p>这里指方法2和方法3. 显然的, 我们推荐使用方法3:</p>
<pre><code>class F():
    def __init__(self):
        self._b = None

    @tf.function
    def __call__(self):
        a = tf.constant([[10, 10], [11., 1.]])
        x = tf.constant([[1., 0.], [0., 1.]])
        if self._b is None:
            self._b = tf.Variable(12.)
        y = tf.matmul(a, x) + self._b
        print(&quot;PRINT: &quot;, y)
        tf.print(&quot;TF-PRINT: &quot;, y)
        return y

f = F()
f()
</code></pre><h3 id="将状态作为传入参数来处理"><a href="#将状态作为传入参数来处理" class="headerlink" title="将状态作为传入参数来处理"></a>将状态作为传入参数来处理</h3><p>我们之后会看到, 我们并不能随意地用tf.function来转化eager的代码并达到加速的目的, 我们需要想象一下转化是怎么完成的, 在转python的代码到图操作的时候究竟发生了什么, 这些转化包含了什么黑魔法. 这里的例子比较简单, 我们会在接下来的文章中更深入的探讨.</p>
<pre><code>@tf.function
def f(b):
    a = tf.constant([[10,10],[11.,1.]])
    x = tf.constant([[1.,0.],[0.,1.]])
    y = tf.matmul(a, x) + b
    print(&quot;PRINT: &quot;, y)
    tf.print(&quot;TF-PRINT: &quot;, y)
    return y

b = tf.Variable(12.)
f(b)
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>我们可以用@tf.function装饰器来将python代码转成图表示代码</li>
<li>我们不能在被装饰函数中初始化tf.Variable</li>
<li>可以用变量作用域继承(对象属性)或者参数传入的方法使用在函数外初始化的变量</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/svm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/svm/" itemprop="url">支持向量机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/监督学习/" itemprop="url" rel="index">
                    <span itemprop="name">监督学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SVM适合处理什么样的数据"><a href="#SVM适合处理什么样的数据" class="headerlink" title="SVM适合处理什么样的数据"></a>SVM适合处理什么样的数据</h3><blockquote>
<p>高维稀疏，样本少。【参数只与支持向量有关，数量少，所以需要的样本少，由于参数跟维度没有关系，所以可以处理高维问题】</p>
</blockquote>
<h3 id="线性核VS径向基核"><a href="#线性核VS径向基核" class="headerlink" title="线性核VS径向基核"></a>线性核VS径向基核</h3><ol>
<li>训练速度：线性核只需要调节惩罚因子一个参数，所以速度快；径向基核函数还需要调节γ，所以训练速度变慢。【调参一般使用交叉验证，所以速度会慢】</li>
<li>训练结果：线性核的得到的权重w可以反映出特征的重要性，从而进行特征选择；径向基核得到权重是无法解释的。</li>
<li>适应的数据：线性核：样本数量远小于特征数量(n&lt;<m）【此时不需要映射到高维】，或者样本数量与特征数量都很大。【此时主要考虑训练速度】径向基核：样本数量远大于特征数量(n>&gt;m)。</m）【此时不需要映射到高维】，或者样本数量与特征数量都很大。【此时主要考虑训练速度】径向基核：样本数量远大于特征数量(n></li>
</ol>
<h3 id="径向基核函数中参数的物理意义"><a href="#径向基核函数中参数的物理意义" class="headerlink" title="径向基核函数中参数的物理意义"></a>径向基核函数中参数的物理意义</h3><blockquote>
<p>如果σ选得很大的话，高次特征上的权重实际上衰减得非常快【使用泰勒展开就可以发现，当很大的时候，泰勒展开的高次项的系数会变小得很快】，所以实际上（数值上近似一下）相当于一个低维的子空间；反过来，如果σ选得很小，则可以将任意的数据映射为线性可分——当然，这并不一定是好事，因为随之而来的可能是非常严重的过拟合问题【很难理解这里的说法？？？】【因为此时泰勒展开式中有效的项将变得非常多，甚至无穷多，那么就相当于映射到了一个无穷维的空间，任意数据都将变得线性可分】</p>
</blockquote>
<h3 id="多项式核VS径向基核"><a href="#多项式核VS径向基核" class="headerlink" title="多项式核VS径向基核"></a>多项式核VS径向基核</h3><ol>
<li>计算量：径向基核需要计算e的幂，所以比较耗时</li>
<li>可解释性：多项式核的结果更加直观，解释性强，所以如果对数据有一定的了解的话，可以考虑使用多项式核</li>
<li>参数：多项式核参数多，难调</li>
</ol>
<h3 id="如何选择核函数"><a href="#如何选择核函数" class="headerlink" title="如何选择核函数"></a>如何选择核函数</h3><blockquote>
<p>线性核是高斯核的特例，sigmoid核在给定的参数下和高斯核相似，多项式核的参数太多；对于高斯核0&lt;Kij&lt;1，而多项式核则可能会出现无穷大或无穷小；对于特征非常多的情况下，应使用线性核。因为此时特征够用了(很大可能是线性问题)，没必要映射到更高维的特征空间线性核的训练速度快，而且一般情况下效果还不错，尤其是维度高的情况下。其他核需要调参（使用交叉验证），所以速度慢。PS：高斯核必然映射到无穷维，因为核函数的泰勒展开有无穷多项。</p>
</blockquote>
<h3 id="为什么SVM训练的时候耗内存，而预测的时候占内存少"><a href="#为什么SVM训练的时候耗内存，而预测的时候占内存少" class="headerlink" title="为什么SVM训练的时候耗内存，而预测的时候占内存少"></a>为什么SVM训练的时候耗内存，而预测的时候占内存少</h3><blockquote>
<p>因为SVM训练过程中需要存储核矩阵。而预测的时候只需要存储支持向量和相关参数。</p>
</blockquote>
<h3 id="样本失衡会对SVM的结果产生影响吗"><a href="#样本失衡会对SVM的结果产生影响吗" class="headerlink" title="样本失衡会对SVM的结果产生影响吗"></a>样本失衡会对SVM的结果产生影响吗</h3><blockquote>
<p>会，超平面会靠近样本少的类别。因为使用的是软间隔分类，而如果对所有类别都是使用同样的惩罚系数，则由于优化目标里面有最小化惩罚量，所以靠近少数样本时，其惩罚量会少一些。</p>
<p>比如：假设理想的分隔超平面是大样本中有很多数据到该超平面的函数距离是小于1的，<br>而小样本中是只有少数样本的函数距离小于1的。但是由于惩罚系数相同，实际算法得到的超平面会往小样本数据靠近。</p>
</blockquote>
<h3 id="样本失衡时，SVM可以采取什么样的方法解决"><a href="#样本失衡时，SVM可以采取什么样的方法解决" class="headerlink" title="样本失衡时，SVM可以采取什么样的方法解决"></a>样本失衡时，SVM可以采取什么样的方法解决</h3><ol>
<li>采用既能代表多数类样本分布特征, 又能对分类界面有一定影响的样本特性欠抽样方法</li>
<li>对多数类和和少数类采用不同的惩罚因子</li>
</ol>
<h3 id="样本没有规范化对SVM有什么影响"><a href="#样本没有规范化对SVM有什么影响" class="headerlink" title="样本没有规范化对SVM有什么影响"></a>样本没有规范化对SVM有什么影响</h3><blockquote>
<p>对偶问题的优化目标函数中有向量的内积计算(优化过程中也会有内积计算的，见SMO)，径向基核函数中有向量的距离计算，存在值域小的变量会被忽略的问题，影响算法的精度。</p>
</blockquote>
<h3 id="γ和C对RBF的影响"><a href="#γ和C对RBF的影响" class="headerlink" title="γ和C对RBF的影响"></a>γ和C对RBF的影响</h3><h4 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h4><blockquote>
<p>增大γ使钟型曲线更窄，导致每个样本的影响范围变得更小：即判定边界最终变得更不规则，在单个样本周围环绕。相反的，较小的γ值使钟型曲线更宽，样本有更大的影响范围，判定边界最终则更加平滑。所以γ是可调整的超参数：如果你的模型过拟合，你应该减小γ值，若欠拟合，则增大γ（与超参数C相似）。 </p>
<p>当γ比较大时，我们会有更多的支持向量，我们的模型会比较复杂，容易过拟合一些。如果γ比较小，模型会变得简单，支持向量的个数会少。</p>
</blockquote>
<h4 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h4><blockquote>
<p>SVM回归模型的RBF核比分类模型要复杂一点，因为此时我们除了惩罚系数C和RBF核函数的系数γ之外，还多了一个损失距离度量ϵ。如果是nu-SVR的话，损失距离度量ϵ代替为分类错误率上限nu，由于损失距离度量ϵ和分类错误率上限nu起的作用等价，因此本文只讨论带距离度量ϵ的回归SVM。</p>
<p>对于惩罚系数C和RBF核函数的系数γ，回归模型和分类模型的作用基本相同。对于损失距离度量ϵ，它决定了样本点到超平面的距离损失，当ϵ比较大时，损失|yi−w∙ϕ(xi)−b|−ϵ较小，更多的点在损失距离范围之内，而没有损失,模型较简单，而当ϵ比较小时，损失函数会较大，模型也会变得复杂。scikit-learn中默认值是0.1。</p>
<p>如果把惩罚系数C，RBF核函数的系数γ和损失距离度量ϵ一起看，当C比较大， γ比较大，ϵ比较小时，我们会有更多的支持向量，我们的模型会比较复杂，容易过拟合一些。如果C比较小 ， γ比较小，ϵ比较大时，模型会变得简单，支持向量的个数会少。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="#/2019/12/30/线性变化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="童双双">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="童双双">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/30/线性变化/" itemprop="url">线性变换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">
                2019-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="万物皆矩阵"><a href="#万物皆矩阵" class="headerlink" title="万物皆矩阵"></a><font color="red"><strong>万物皆矩阵</strong></font></h1><h1 id="特征向量与特征值"><a href="#特征向量与特征值" class="headerlink" title="特征向量与特征值"></a>特征向量与特征值</h1><script type="math/tex; mode=display">
A\nu = \lambda\nu</script><script type="math/tex; mode=display">
A(\nu_1,\nu_2,...,\nu_n) = 
(\nu_1,\nu_2,...,\nu_n)
{\begin{pmatrix}
\lambda_1 & 0 & ...&0\\\\
0 & \lambda_2&...&0\\\\
...&...&...&0\\\\
...&...&0&\lambda_n
\end{pmatrix}}_{n \times n}</script><p>当$A$为对称阵时，A的特征向量两两正交且为单位向量。$\nu$越小，则$A$在特征空间的映射越小，换句话说，该维度的特征作用越小。<strong><font color="red">对称阵一定能相似对角化。</font></strong></p>
<p>经过线性变换$A$，特征向量所在的空间并没有发生旋转，只是发生了伸缩变换，伸缩的因子便是特征值。</p>
<p>特征值不相等，对应的特征向量线性无关。</p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>对于对称阵A：$A=U \nu U^T$，完成了矩阵分解。利用$A$对一个向量$x$进行变换，$Ax=U \nu U^Tx$：</p>
<script type="math/tex; mode=display">
Ax = 
\begin{bmatrix}
x_1&x_2&...&x_m
\end{bmatrix}

{\begin{bmatrix}
\lambda_1 & ... & ... \\\\ 
... & \lambda_i & ... \\\\ 
... & ... & \lambda_m
\end{bmatrix}}

\begin{bmatrix}
x_1^T\\\\
x_2^T\\\\
...\\\\
x_m^T
\end{bmatrix}
x</script><p>对等式右边做一些解释：</p>
<p><strong>1.</strong> $U^T$的每一行对应一个单位正交向量，也可以说它的所有行构成了一组新的单位正交基。$U^Tx$的结果相当于$U^T$的每一行与$x$向量做内积，内积的几何意义在于一个向量$x$在另一向量$x_1^T$ 上的投影再乘以 $x_1^T$的模，对于单位向量$x_1^T$来说，这个模为1。所以， $U^Tx$的几何意义就是一个正交变换，将$x$向量映射到新的正交基上，其结果为新基上的坐标。这个过程可以看作是旋转。</p>
<p><strong>2.</strong> 再看${\nu}U^Tx$ ， $\nu$是一个对角矩阵，对角矩阵的元素即为$A$的特征值。这个过程相当于对$U^Tx$的结果的每一维做了一个拉伸或收缩，且如果某一维度的特征值为0，则这一维度直接去除。</p>
<p><strong>3.</strong> 最后看$U{\nu}U^Tx$ ，与1同理，同样是进行一个单位正交变换，由于$U$和$U^T$是互为逆矩阵，所以$U$变换是$U^T$变换的逆变换。</p>
<p><strong>4.</strong> 特征分解的意义：</p>
<pre><code>假设对称阵特征值全为1那么显然它就是单位阵，如果对称阵的特征值有个别是0其他全是1，那么它就是一个正交投影矩阵，它将m维向量投影到它的列空间中。
</code></pre><h2 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h2><p>SVD分解的结果为：$A=U{\Sigma}V^T$</p>
<p>其中$U=\begin{bmatrix}u_1&amp;u_2&amp;…&amp;u_n\end{bmatrix},V=\begin{bmatrix}v_1&amp;v_2&amp;…&amp;v_m\end{bmatrix},\Sigma=\begin{bmatrix}\lambda_1&amp;\lambda_2&amp;…&amp;\lambda_m\end{bmatrix},(m&lt;n)$</p>
<p>令$B=AA^T,C = A^TA$，则有：</p>
<script type="math/tex; mode=display">
B=UDU^T = U\Sigma^T\Sigma U^T =(U\Sigma^TV^T)(V\Sigma U^T)</script><script type="math/tex; mode=display">
C=VDV^T = V\Sigma^T\Sigma V^T =(V\Sigma^TU^T)(U\Sigma V^T)</script><script type="math/tex; mode=display">
A = \begin{pmatrix}
u_1&u_2&...&u_n
\end{pmatrix}

\begin{pmatrix}
\lambda_1&...&...&0\\\\
0&\lambda_2&...&0\\\\
...&...&...&...\\\\
...&...&...&\lambda_m\\\\
...&...&...&0&
\end{pmatrix}

\begin{pmatrix}
v_1^T\\\\
v_2^T\\\\
...\\\\
v_m^T
\end{pmatrix}</script><p>则<br>$A=\lambda_1 u_1 v_1^T +…+ \lambda_m u_m v_m^T<br>$</p>
<p>与特征分解意义类似：<br>$A$是一个线性变换，把$A$分解成$U{\Sigma}V^T$，$\sum$给出了变换后椭圆长短轴的长度， $U$和$V^T$一起确定了变换后的方向，所以$U,\Sigma,V^T$ 包含了这个线性变换的全部信息。$\Sigma$矩阵的对角线元素称为$A$的奇异值，与特征值一样，大的奇异值对应长轴，小的奇异值对应短轴，大的奇异值包含更多信息。</p>
<p>假设我们要对$A_{m\times n}$进行降维，那么通过奇异值分解 $A_{m\times n}=U_{m\times m}\Sigma_{m\times n}V_{n\times n}$，等式两边等价。由于 $\Sigma_{m\times n}$ 的对角线元素，也就是奇异值的分布是：几乎前10%甚至1%的奇异值的和占了全部奇异值只和的99%以上，也就是说，我们也可以用最大的k个的奇异值和对应的左右奇异向量U和V来近似描述矩阵，即：</p>
<script type="math/tex; mode=display">
A_{m\times n}=U_{m\times m}\Sigma_{m\times n}V_{n\times n}\approx U_{m\times k}\Sigma_{k\times k}V_{k\times n}</script><h2 id="旋转变换和反射变换（镜像）"><a href="#旋转变换和反射变换（镜像）" class="headerlink" title="旋转变换和反射变换（镜像）"></a>旋转变换和反射变换（镜像）</h2><p>在线性空间中进行旋转，实际是要改变向量的方向，但是不改变向量的长度和手性。现在假设矩阵$M_{n\times n}$是线性空间$R^n$中的一个旋转变换对应的矩阵，我们来看看它应该是什么样子。考虑向量内积$ab=|a||b|cos(a,b)$。因为旋转不改变向量的长度，且两个向量经过相同的旋转之后，其夹角保持不变。因此，若$M$对应一个旋转变换，那么就必须有</p>
<script type="math/tex; mode=display">
ab = MaMb,</script><p>也就是</p>
<script type="math/tex; mode=display">
ab^T = (Ma)(Mb)^T,</script><p>这也就是说$MM^T=I_n$，亦即$M$是正交矩阵。</p>
<h2 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h2><p>在线性空间中进行缩放，实质就是要让线性空间中的每一维独立地进行变换，而不受其他维度影响。这样一来，很显然，对应的矩阵应该是对角矩阵。</p>
<h2 id="SVD-分解的几何解释"><a href="#SVD-分解的几何解释" class="headerlink" title="SVD 分解的几何解释"></a>SVD 分解的几何解释</h2><p>现在回过头来看 SVD 分解</p>
<script type="math/tex; mode=display">
M = U\Sigma V^H</script><p>在实数范围内讨论，我们实质上是将一个复杂的变换$M:R^m \rightarrow R^n$分解成了三个变换：旋转/镜像$U:R^m \rightarrow R^m$，缩放$\Sigma:R^m \rightarrow R^n$，旋转/镜像$V:R^n \rightarrow R^n$</p>
<p>不妨令$m=n$，不难发现$V^H$ 首先将（可能是退化的）单位球旋转（旋转标准正交基），而后经由 $\Sigma$将单位圆缩放拉伸成椭圆（超空间中的超椭球），再经由$U$将超椭球在 $K^m$空间中旋转。而这个超椭球的各个半轴的长度，就是矩阵$M$的奇异值，也就是矩阵 $\Sigma$对角线上的元素。</p>
<h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><p>设$A,B$都是n阶矩阵，若有可逆矩阵$P$,使得$P^{-1}AP = B$则称$B$是$A$的相似矩阵或者矩阵$A,B$相似。</p>
<p><strong>定理</strong>：若n阶矩阵$A,B$相似，则$A,B$的特征多项式相同，从而$A,B$的特征值相同。</p>
<p><strong>推论</strong>：若n阶矩阵$A$与对角阵</p>
<script type="math/tex; mode=display">
\Sigma = 
\begin{pmatrix}
\lambda_1&...&...&...\\\\
...&\lambda_2&...&...\\\\
...&...&...&...\\\\
...&...&...&\lambda_n
\end{pmatrix}</script><p>相似，则$\lambda_1,…,\lambda_n$是$A$的特征值，$P$的列向量是$A$的特征向量。</p>
<p>有$\Phi(A) = P\Phi(\Sigma)P^{-1}$。</p>
<p><em>注：不是所有的方阵都可以相似对角化，因为不是所有的方阵的特征向量都线性无关。<font color="red">对称阵一定可以相似对角化</font>。</em></p>
<h2 id="矩阵对角化"><a href="#矩阵对角化" class="headerlink" title="矩阵对角化"></a>矩阵对角化</h2><p><strong>n阶矩阵$M$相似于对角矩阵的充要条件是$M$有n个线性无关的特征向量。</strong></p>
<p>矩阵$M$为$n\times n$矩阵，其特征值为$\lambda_1,\lambda_2,…,\lambda_n$，<font color="red"><strong>特征向量为$v_1,v_2,…,v_n$，形成线性无关集合</strong></font>，令$A=\begin{bmatrix}v_1&amp;v_2&amp;…&amp;v_n\end{bmatrix}$，则有</p>
<script type="math/tex; mode=display">
A^{-1}MA = 
A^{-1}Adiag(\lambda_1,\lambda_2,...,\lambda_n)=
\begin{pmatrix}
\lambda_1&0&...&0\\\\
0&\lambda_2&...&0\\\\
...&...&...&...\\\\
0&0&...&\lambda_n
\end{pmatrix}</script><p><font color="yellow"><strong>对于对称阵而言，特征向量是正交的，则以单位特征向量构成的矩阵$A$是正交矩阵，因此$A^{-1}=A^T$。</strong></font>对称阵的特征向量组一定线性无关。</p>
<h3 id="对称矩阵的对角化"><a href="#对称矩阵的对角化" class="headerlink" title="对称矩阵的对角化"></a>对称矩阵的对角化</h3><p><strong>定理：</strong> </p><p>设$\lambda_1,\lambda_2$是对称阵$A$的两个特征值，$P_1,P_2$是对应的特征向量。若$\lambda_1\neq\lambda_2$，则$P_1,P_2$正交。</p><p></p>
<p><strong>定理：</strong> </p><p>设$A$为n阶对称阵，则必有正交阵$P$，使得$P^{-1}AP = P^TAP=\nu$，其中$\nu$是以$A$的n个特征值为对角元的对角阵。</p><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/cat.jpg" alt="童双双">
            
              <p class="site-author-name" itemprop="name">童双双</p>
              <p class="site-description motion-element" itemprop="description">年华似水 匆匆一瞥 多少岁月 轻描淡写</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

        



            
            <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
            <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
            <div class="widget-wrap">
            <h3 class="widget-title">Tag Cloud</h3>
            <div id="myCanvasContainer" class="widget tagcloud">
                <canvas width="250" height="250" id="resCanvas" style="width=100%">
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow2-0/">Tensorflow2.0</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keras/">keras</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/numpy/">numpy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协同过滤/">协同过滤</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐算法/">推荐算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/推荐系统/">推荐系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数列/">数列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模型评估与选择/">模型评估与选择</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/监督学习/">监督学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性方程组/">线性方程组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性空间/">线性空间</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/行列式/">行列式</a><span class="tag-list-count">1</span></li></ul>
                </canvas>
            </div>
            </div>
            



          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TSS2" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://sklearn.apachecn.org" target="_blank" title="sklearn">
                      
                        <i class="fa fa-fw fa-globe"></i>sklearn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://tensorflow.google.cn/" target="_blank" title="Tensorflow">
                      
                        <i class="fa fa-fw fa-globe"></i>Tensorflow</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">童双双</span>

  
</div>










    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    



  <script src="https://unpkg.com/mermaid@<%= theme.mermaid.version %>/dist/mermaid.min.js"></script>
    <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  






   
   
   
   
 	<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
	<script src="https://billts.site/js/gitment.js"></script>
   
       <script type="text/javascript">
           var gitment = new Gitment({
               id: decodeURI(window.location.pathname), 
               owner: 'TSS2',
               repo: 'TSS2.github.io',
               oauth: {
                   client_id: '624d201125f2580545ab',
                   client_secret: '35238e26f8067cff44176e8a83e37e1bc303bb73',
               }});
           gitment.render('gitment-container');
       </script>
   




  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
